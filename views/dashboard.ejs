<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Engesense - Energy Dashboard</title>
  
  <!-- Google Fonts - Roboto -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

  <!-- Flatpickr CSS for the calendar input -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
  />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css"
  />
  
  <!-- Material Design System -->
  <link rel="stylesheet" href="/css/design-system.css">
  <link rel="stylesheet" href="/css/chart-controls.css">

  <style>
    /* Dashboard-specific styles that complement the Material Design system */
    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Header styling with Material Design */
    .dashboard-header {
      background-color: var(--md-surface);
      border-bottom: 1px solid var(--md-outline);
      padding: var(--md-spacing-md) var(--md-spacing-lg);
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: var(--md-shadow-1);
    }
    
    .header-content {
      display: flex;
      align-items: center;
      gap: var(--md-spacing-lg);
    }
    
    .header-logo img {
      width: 60px;
      height: auto;
      border-radius: var(--md-radius-sm);
    }
    
    .welcome-text {
      color: var(--md-primary);
      font-size: var(--md-font-size-h5);
      font-weight: var(--md-font-weight-medium);
      margin: 0;
    }

    /* Controls Section */
    .controls-section {
      background-color: var(--md-surface);
      border-bottom: 1px solid var(--md-outline);
      padding: var(--md-spacing-lg);
      display: flex;
      flex-wrap: wrap;
      gap: var(--md-spacing-md);
      align-items: center;
      box-shadow: var(--md-shadow-1);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: var(--md-spacing-xs);
    }

    .control-label {
      font-size: var(--md-font-size-body2);
      font-weight: var(--md-font-weight-medium);
      color: var(--md-on-surface-variant);
      margin-bottom: var(--md-spacing-xs);
    }

    /* Dropdown styling */
    .dropdown-container {
      position: relative;
      min-width: 200px;
      max-width: 300px;
    }

    .dropdown-trigger {
      width: 100%;
      padding: var(--md-spacing-md);
      border: 1px solid var(--md-outline);
      border-radius: var(--md-radius-sm);
      background-color: var(--md-surface);
      color: var(--md-on-surface);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all var(--md-transition-fast);
      font-family: var(--md-font-family);
      font-size: var(--md-font-size-body1);
    }

    .dropdown-trigger:hover {
      border-color: var(--md-primary);
      background-color: var(--md-surface-variant);
    }

    .dropdown-trigger:focus {
      outline: none;
      border-color: var(--md-primary);
      box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.12);
    }

    .dropdown-content {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background-color: var(--md-surface);
      border: 1px solid var(--md-outline);
      border-radius: var(--md-radius-sm);
      box-shadow: var(--md-shadow-2);
      z-index: 1000;
      max-height: 250px;
      overflow-y: auto;
      margin-top: var(--md-spacing-xs);
      display: none;
    }

    .dropdown-content.open {
      display: block;
    }

    .dropdown-item {
      padding: var(--md-spacing-md);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: var(--md-spacing-sm);
      transition: background-color var(--md-transition-fast);
    }

    .dropdown-item:hover {
      background-color: var(--md-surface-variant);
    }

    /* Time Range Controls */
    .time-range-group {
      display: flex;
      align-items: center;
      gap: var(--md-spacing-sm);
      padding: var(--md-spacing-md);
      background-color: var(--md-surface-variant);
      border-radius: var(--md-radius-md);
      border: 1px solid var(--md-outline-variant);
    }

    .time-mode-buttons {
      display: flex;
      gap: var(--md-spacing-xs);
    }

    .time-quick-buttons {
      display: flex;
      gap: var(--md-spacing-xs);
      flex-wrap: wrap;
    }

    #rangePicker {
      display: none;
      min-width: 220px;
      padding: var(--md-spacing-sm);
      border: 1px solid var(--md-outline);
      border-radius: var(--md-radius-sm);
      background-color: var(--md-surface);
      color: var(--md-on-surface);
      font-family: var(--md-font-family);
    }

    /* Export section */
    .export-group {
      display: flex;
      gap: var(--md-spacing-sm);
      align-items: center;
    }

    /* Chart Container */
    .chart-section {
      flex: 1;
      padding: var(--md-spacing-lg);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .chart-card {
      width: 100%;
      max-width: 1200px;
      padding: var(--md-spacing-xl);
      min-height: 600px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #sensorChart {
      width: 100%;
      height: 600px;
    }

    /* Statistics Section */
    .stats-section {
      padding: 0 var(--md-spacing-lg) var(--md-spacing-lg);
    }

    .stats-card {
      padding: var(--md-spacing-xl);
    }

    .stats-title {
      color: var(--md-primary);
      margin-bottom: var(--md-spacing-lg);
      font-size: var(--md-font-size-h6);
      font-weight: var(--md-font-weight-medium);
    }

    .stats-table {
      width: 100%;
      border-collapse: collapse;
      font-size: var(--md-font-size-body2);
    }

    .stats-table th {
      background-color: var(--md-surface-variant);
      color: var(--md-primary);
      padding: var(--md-spacing-md);
      text-align: left;
      font-weight: var(--md-font-weight-medium);
      border-bottom: 2px solid var(--md-outline);
    }

    .stats-table td {
      padding: var(--md-spacing-md);
      border-bottom: 1px solid var(--md-outline-variant);
    }

    .stats-table th:not(:first-child),
    .stats-table td:not(:first-child) {
      text-align: right;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .controls-section {
        padding: var(--md-spacing-md);
        gap: var(--md-spacing-sm);
      }

      .control-group {
        width: 100%;
      }

      .dropdown-container {
        min-width: unset;
        width: 100%;
      }

      .time-range-group {
        flex-direction: column;
        align-items: stretch;
        gap: var(--md-spacing-md);
        width: 100%;
      }

      .time-quick-buttons {
        justify-content: center;
      }

      .export-group {
        width: 100%;
        justify-content: center;
      }

      .chart-card {
        padding: var(--md-spacing-lg);
        min-height: 400px;
      }

      #sensorChart {
        height: 400px;
      }

      .header-content {
        gap: var(--md-spacing-md);
      }

      .welcome-text {
        font-size: var(--md-font-size-body1);
      }
    }

    @media (max-width: 480px) {
      .dashboard-header {
        padding: var(--md-spacing-sm) var(--md-spacing-md);
      }

      .controls-section {
        padding: var(--md-spacing-sm);
      }

      .time-quick-buttons {
        gap: var(--md-spacing-xs);
      }

      .chart-card {
        padding: var(--md-spacing-md);
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="dashboard-header">
    <div class="header-content">
      <div class="header-logo">
        <img src="/images/logo.jpg" alt="Engesense Logo">
      </div>
      <h1 class="welcome-text">Welcome, <%= user.username %> (<%= user.role %>)</h1>
    </div>
    
    <div style="display: flex; align-items: center; gap: var(--md-spacing-md);">
      <% if (user.role === 'admin') { %>
        <a href="/admin/users" class="md-button md-button-outlined md-button-small">
          <span class="md-icon md-icon-sm">üë•</span>
          Manage Users
        </a>
      <% } %>
      
      <form method="POST" action="/logout">
        <button type="submit" class="md-button md-button-text">
          <span class="md-icon md-icon-sm">üö™</span>
          Logout
        </button>
      </form>
    </div>
  </header>

  <!-- Controls Section -->
  <div class="controls-section">
    <!-- Bucket Selection -->
    <div class="control-group">
      <label class="control-label">Data Sources</label>
      <div class="dropdown-container" id="bucketsDropdown">
        <div class="dropdown-trigger" tabindex="0">
          <span class="dropdown-text">Loading buckets...</span>
          <span class="dropdown-arrow">‚ñº</span>
        </div>
        <div class="dropdown-content">
          <!-- Options will be populated dynamically -->
        </div>
      </div>
    </div>
    
    <!-- Measurement Selection -->
    <div class="control-group">
      <label class="control-label">Measurements</label>
      <div class="dropdown-container" id="measurementsDropdown">
        <div class="dropdown-trigger" tabindex="0">
          <span class="dropdown-text">Select buckets first</span>
          <span class="dropdown-arrow">‚ñº</span>
        </div>
        <div class="dropdown-content">
          <!-- Options will be populated dynamically -->
        </div>
      </div>
    </div>

    <!-- Time Range Controls -->
    <div class="control-group">
      <label class="control-label">Time Range</label>
      <div class="time-range-group">
        <!-- Mode toggles -->
        <div class="time-mode-buttons">
          <button id="btn-relative" class="md-button md-button-filled md-button-small">Relative</button>
          <button id="btn-absolute" class="md-button md-button-outlined md-button-small">Calendar</button>
        </div>

        <!-- Relative-range quick buttons -->
        <div id="relative-controls" class="time-quick-buttons">
          <button class="md-button md-button-outlined md-button-small" data-range="-5m">5 min</button>
          <button class="md-button md-button-outlined md-button-small" data-range="-15m">15 min</button>
          <button class="md-button md-button-outlined md-button-small" data-range="-30m">30 min</button>
          <button class="md-button md-button-outlined md-button-small" data-range="-1h">1 hour</button>
          <button class="md-button md-button-outlined md-button-small" data-range="-6h">6 hours</button>
          <button class="md-button md-button-outlined md-button-small" data-range="-12h">12 hours</button>
          <button class="md-button md-button-outlined md-button-small" data-range="-1d">1 day</button>
        </div>

        <!-- Flatpickr date-range input -->
        <input
          id="rangePicker"
          type="text"
          placeholder="Select date & time range"
          readonly
        />
        
        <!-- Refresh button -->
        <button id="refresh-btn" class="md-button md-button-filled md-button-small" style="background-color: var(--md-success);">
          <span class="md-icon md-icon-sm">üîÑ</span>
          Refresh
        </button>
      </div>
    </div>

    <!-- Export section -->
    <div class="control-group">
      <label class="control-label">Export Data</label>
      <div class="export-group">
        <form method="GET" action="/export" class="export-form">
          <input type="hidden" name="range" id="csvRange" value="">
          <input type="hidden" name="start" id="csvStart" value="">
          <input type="hidden" name="stop" id="csvStop" value="">
          <input type="hidden" name="buckets" id="csvBuckets" value="">
          <input type="hidden" name="measurements" id="csvMeasurements" value="">
          <input type="hidden" name="format" value="csv">
          <button type="submit" class="md-button md-button-outlined md-button-small">
            <span class="md-icon md-icon-sm">üìÑ</span>
            CSV
          </button>
        </form>
        
        <form method="GET" action="/export" class="export-form">
          <input type="hidden" name="range" id="excelRange" value="">
          <input type="hidden" name="start" id="excelStart" value="">
          <input type="hidden" name="stop" id="excelStop" value="">
          <input type="hidden" name="buckets" id="excelBuckets" value="">
          <input type="hidden" name="measurements" id="excelMeasurements" value="">
          <input type="hidden" name="format" value="excel">
          <button type="submit" class="md-button md-button-outlined md-button-small" style="color: var(--md-success); border-color: var(--md-success);">
            <span class="md-icon md-icon-sm">üìä</span>
            Excel
          </button>
        </form>
      </div>
    </div>
  </div>

  <!-- Enhanced Chart Controls -->
  <div class="chart-controls" id="chart-controls" style="display: none;">
    <!-- Chart Type Selection -->
    <div class="chart-control-group">
      <div class="chart-control-label">Chart Type</div>
      <div class="chart-type-buttons">
        <button class="chart-type-button active" data-type="line">Line</button>
        <button class="chart-type-button" data-type="area">Area</button>
        <button class="chart-type-button" data-type="bar">Bar</button>
        <button class="chart-type-button" data-type="scatter">Scatter</button>
      </div>
    </div>

    <!-- Visual Features -->
    <div class="chart-control-group">
      <div class="chart-control-label">Visual Options</div>
      <div class="chart-control-buttons">
        <button class="chart-feature-toggle active" id="toggle-points">Points</button>
        <button class="chart-feature-toggle" id="toggle-fill">Fill Area</button>
        <button class="chart-feature-toggle active" id="toggle-grid">Grid</button>
        <button class="chart-feature-toggle active" id="toggle-legend">Legend</button>
      </div>
    </div>

    <!-- Line Style -->
    <div class="chart-control-group">
      <div class="chart-control-label">Line Style</div>
      <div class="chart-control-buttons">
        <button class="chart-feature-toggle active" data-line-style="solid">Solid</button>
        <button class="chart-feature-toggle" data-line-style="dashed">Dashed</button>
        <button class="chart-feature-toggle" data-line-style="dotted">Dotted</button>
      </div>
    </div>

    <!-- Color Palette -->
    <div class="chart-control-group">
      <div class="chart-control-label">Color Palette</div>
      <div class="chart-color-palette">
        <div class="color-palette-option default active" data-palette="default" title="Default"></div>
        <div class="color-palette-option vibrant" data-palette="vibrant" title="Vibrant"></div>
        <div class="color-palette-option pastel" data-palette="pastel" title="Pastel"></div>
        <div class="color-palette-option monochrome" data-palette="monochrome" title="Monochrome"></div>
      </div>
    </div>

    <!-- Chart Actions -->
    <div class="chart-actions">
      <div class="chart-zoom-controls">
        <button class="chart-action-button" id="zoom-out">üîç-</button>
        <span class="zoom-level-indicator" id="zoom-level">100%</span>
        <button class="chart-action-button" id="zoom-in">üîç+</button>
        <button class="chart-action-button" id="reset-zoom">‚Ü∫</button>
      </div>
      <button class="chart-action-button" id="export-png">üì∑ PNG</button>
      <button class="chart-action-button" id="fullscreen-chart">‚õ∂ Fullscreen</button>
    </div>

    <!-- Advanced Controls -->
    <div class="advanced-controls">
      <!-- Y-Axis Type -->
      <div class="chart-control-group">
        <div class="chart-control-label">Y-Axis Scale</div>
        <div class="chart-control-buttons">
          <button class="chart-feature-toggle active" data-y-axis="linear">Linear</button>
          <button class="chart-feature-toggle" data-y-axis="logarithmic">Log</button>
        </div>
      </div>

      <!-- Data Processing -->
      <div class="chart-control-group">
        <div class="chart-control-label">Data Processing</div>
        <div class="chart-control-buttons">
          <button class="chart-feature-toggle" id="toggle-smoothing">Smoothing</button>
          <button class="chart-feature-toggle" id="toggle-moving-avg">Moving Avg</button>
        </div>
      </div>

      <!-- Moving Average Period -->
      <div class="range-control" id="ma-period-control" style="display: none;">
        <div class="chart-control-label">MA Period</div>
        <input type="range" class="range-input" id="ma-period" min="2" max="20" value="5">
        <div class="range-value" id="ma-period-value">5</div>
      </div>
    </div>
  </div>

  <!-- Chart Section -->
  <div class="chart-section">
    <div class="md-card enhanced-chart-container md-elevation-2">
      <div class="chart-header">
        <h3 class="chart-title">Sensor Data Visualization</h3>
        <div class="chart-status">
          <div class="status-indicator" id="chart-status"></div>
          <span id="chart-status-text">Ready</span>
        </div>
      </div>
      <div class="chart-card">
        <canvas id="sensorChart"></canvas>
        <div class="chart-loading" id="chart-loading" style="display: none;">Loading chart data...</div>
      </div>
    </div>
  </div>

  <!-- Statistics Section -->
  <div class="stats-section">
    <div class="md-card stats-card md-elevation-1">
      <h3 class="stats-title">Statistics Summary</h3>
      <table class="stats-table" id="stats-table">
        <thead>
          <tr>
            <th>Measurement</th>
            <th>Minimum</th>
            <th>Average</th>
            <th>Maximum</th>
          </tr>
        </thead>
        <tbody>
          <!-- Stats rows will be inserted here -->
        </tbody>
      </table>
    </div>
  </div>

  <!-- Scripts -->
  <script src="/css/theme-system.js"></script>

  <!-- Flatpickr & Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Enhanced chart implementation -->
  <script src="/js/enhanced-chart.js"></script>
  <!-- Fallback chart implementation when Chart.js is not available -->
  <script src="/js/fallback-chart.js"></script>

  <script>
    // Elements
    const btnRel     = document.getElementById('btn-relative');
    const btnAbs     = document.getElementById('btn-absolute');
    const relCtrls   = document.getElementById('relative-controls');
    const refreshBtn = document.getElementById('refresh-btn');
    const csvRange = document.getElementById('csvRange');
    const csvStart = document.getElementById('csvStart');
    const csvStop  = document.getElementById('csvStop');
    const excelRange = document.getElementById('excelRange');
    const excelStart = document.getElementById('excelStart');
    const excelStop  = document.getElementById('excelStop');
    const rangeInput = document.getElementById('rangePicker');
    const bucketsDropdown = document.getElementById('bucketsDropdown');
    const measurementsDropdown = document.getElementById('measurementsDropdown');

    let currentRange = '-1h';
    let chart;
    let selectedBuckets = [];
    let selectedMeasurements = [];

    // Chart status management
    function updateChartStatus(status, message) {
      const statusIndicator = document.getElementById('chart-status');
      const statusText = document.getElementById('chart-status-text');
      
      if (statusIndicator && statusText) {
        statusIndicator.className = `status-indicator ${status}`;
        statusText.textContent = message;
      }
    }

    // Display formatter for measurements: bucket:measurement -> bucket (measurement)
    const measurementDisplayFormatter = (measurement) => {
      if (measurement.includes(':')) {
        const [bucket, m] = measurement.split(':', 2);
        return `${bucket} (${m})`;
      }
      return measurement;
    };

    // Custom dropdown functionality
    function initializeDropdown(dropdownElement, onSelectionChange) {
      const trigger = dropdownElement.querySelector('.dropdown-trigger');
      const content = dropdownElement.querySelector('.dropdown-content');
      const textElement = trigger.querySelector('.dropdown-text');

      // Toggle dropdown
      trigger.addEventListener('click', () => {
        const isOpen = content.classList.contains('open');
        closeAllDropdowns();
        if (!isOpen) {
          content.classList.add('open');
          trigger.classList.add('open');
        }
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!dropdownElement.contains(e.target)) {
          content.classList.remove('open');
          trigger.classList.remove('open');
        }
      });

      // Handle checkbox changes
      content.addEventListener('change', (e) => {
        if (e.target.type === 'checkbox') {
          onSelectionChange();
        }
      });

      return { trigger, content, textElement };
    }

    function closeAllDropdowns() {
      document.querySelectorAll('.dropdown-content.open').forEach(content => {
        content.classList.remove('open');
      });
      document.querySelectorAll('.dropdown-trigger.open').forEach(trigger => {
        trigger.classList.remove('open');
      });
    }

    function updateDropdownText(dropdownElement, items, selectedItems, displayFormatter = null) {
      const textElement = dropdownElement.querySelector('.dropdown-text');
      if (selectedItems.length === 0) {
        // Special case for measurements dropdown when no buckets are selected
        if (dropdownElement.id === 'measurementsDropdown' && getAllBuckets().length === 0) {
          textElement.textContent = 'No buckets available';
        } else if (dropdownElement.id === 'measurementsDropdown' && selectedBuckets.length === 0) {
          textElement.textContent = 'Select buckets first';
        } else {
          textElement.textContent = items.length === 0 ? 'No items available' : 'Select items...';
        }
      } else if (selectedItems.length === 1) {
        const displayText = displayFormatter ? displayFormatter(selectedItems[0]) : selectedItems[0];
        textElement.textContent = displayText;
      } else {
        textElement.textContent = `${selectedItems.length} items selected`;
      }
    }

    function populateDropdown(dropdownElement, items, selectedItems, displayFormatter = null) {
      const content = dropdownElement.querySelector('.dropdown-content');
      content.innerHTML = '';

      if (items.length === 0) {
        content.innerHTML = '<div class="dropdown-item">No items available</div>';
        return;
      }

      items.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'dropdown-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = item;
        checkbox.checked = selectedItems.includes(item);
        
        const label = document.createElement('label');
        label.textContent = displayFormatter ? displayFormatter(item) : item;
        label.style.cursor = 'pointer';
        label.style.marginLeft = '0.25rem';
        
        itemDiv.appendChild(checkbox);
        itemDiv.appendChild(label);
        
        // Make the whole item clickable
        itemDiv.addEventListener('click', (e) => {
          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        
        content.appendChild(itemDiv);
      });
    }

    // Initialize dropdowns with improved state management
    const bucketsDropdownControls = initializeDropdown(bucketsDropdown, () => {
      const checkboxes = bucketsDropdown.querySelectorAll('input[type="checkbox"]:checked');
      const newSelectedBuckets = Array.from(checkboxes).map(cb => cb.value);
      
      // Only update if the selection actually changed to avoid unnecessary API calls
      if (JSON.stringify(newSelectedBuckets) !== JSON.stringify(selectedBuckets)) {
        selectedBuckets = newSelectedBuckets;
        updateDropdownText(bucketsDropdown, getAllBuckets(), selectedBuckets);
        updateCsvFields();
        loadMeasurements();
      }
    });

    // Define the measurements onChange handler with improved state management
    function onMeasurementsChange() {
      const checkboxes = measurementsDropdown.querySelectorAll('input[type="checkbox"]:checked');
      const newSelectedMeasurements = Array.from(checkboxes).map(cb => cb.value);
      
      // Only update if the selection actually changed to avoid unnecessary API calls
      if (JSON.stringify(newSelectedMeasurements) !== JSON.stringify(selectedMeasurements)) {
        selectedMeasurements = newSelectedMeasurements;
        updateDropdownText(measurementsDropdown, getAllMeasurements(), selectedMeasurements, measurementDisplayFormatter);
        updateCsvFields();
        if (selectedMeasurements.length > 0) {
          loadAndRender();
        }
      }
    }
    
    const measurementsDropdownControls = initializeDropdown(measurementsDropdown, onMeasurementsChange);

    let allBuckets = [];
    let allMeasurements = [];

    function getAllBuckets() { return allBuckets; }
    function getAllMeasurements() { return allMeasurements; }

    // Load available buckets on page load
    async function loadBuckets() {
      try {
        const res = await fetch('/api/buckets');
        
        if (!res.ok) {
          console.error('Failed to load buckets: API returned error');
          // When buckets fail to load, clear state and ensure dropdown is properly initialized
          allBuckets = [];
          selectedBuckets = [];
          populateDropdown(bucketsDropdown, [], []);
          updateDropdownText(bucketsDropdown, [], []);
          
          // Clear measurements when buckets fail to load
          allMeasurements = [];
          selectedMeasurements = [];
          populateDropdown(measurementsDropdown, [], []);
          updateDropdownText(measurementsDropdown, [], [], measurementDisplayFormatter);
          return;
        }
        
        const data = await res.json();
        allBuckets = data.buckets || [];
        
        if (allBuckets.length === 0) {
          selectedBuckets = [];
          updateDropdownText(bucketsDropdown, [], []);
          // Clear measurements when no buckets are available
          allMeasurements = [];
          selectedMeasurements = [];
          populateDropdown(measurementsDropdown, [], []);
          updateDropdownText(measurementsDropdown, [], []);
          return;
        }
        
        populateDropdown(bucketsDropdown, allBuckets, selectedBuckets);
        updateDropdownText(bucketsDropdown, allBuckets, selectedBuckets);
        
        // Auto-select first bucket if available and none selected
        if (allBuckets.length > 0 && selectedBuckets.length === 0) {
          selectedBuckets = [allBuckets[0]];
          populateDropdown(bucketsDropdown, allBuckets, selectedBuckets);
          updateDropdownText(bucketsDropdown, allBuckets, selectedBuckets);
          await loadMeasurements();
        }
      } catch (err) {
        console.error('Failed to load buckets:', err);
        allBuckets = [];
        selectedBuckets = [];
        updateDropdownText(bucketsDropdown, [], []);
        // Clear measurements when buckets fail to load
        allMeasurements = [];
        selectedMeasurements = [];
        populateDropdown(measurementsDropdown, [], []);
        updateDropdownText(measurementsDropdown, [], []);
      }
    }

    // Load measurements for selected buckets
    async function loadMeasurements() {
      if (selectedBuckets.length === 0) {
        allMeasurements = [];
        selectedMeasurements = [];
        populateDropdown(measurementsDropdown, [], []);
        updateDropdownText(measurementsDropdown, [], [], measurementDisplayFormatter);
        return;
      }
      
      try {
        const bucketsParam = selectedBuckets.join(',');
        const res = await fetch(`/api/measurements?buckets=${encodeURIComponent(bucketsParam)}`);
        
        if (!res.ok) {
          console.error('Failed to load measurements: API returned error');
          allMeasurements = [];
          selectedMeasurements = [];
          populateDropdown(measurementsDropdown, [], []);
          updateDropdownText(measurementsDropdown, [], [], measurementDisplayFormatter);
          return;
        }
        
        const data = await res.json();
        const measurements = data.measurements || [];

        allMeasurements = measurements;
        
        // Filter selectedMeasurements to only include measurements that still exist
        // This preserves user selection when possible, but removes invalid selections
        selectedMeasurements = selectedMeasurements.filter(m => allMeasurements.includes(m));

        if (allMeasurements.length === 0) {
          selectedMeasurements = [];
          populateDropdown(measurementsDropdown, [], []);
          updateDropdownText(measurementsDropdown, [], [], measurementDisplayFormatter);
          return;
        }

        // Use display formatter for bucket:measurement -> bucket (measurement)
        // (Using global formatter instead of local)

        // Auto-select first measurement only if no valid selections remain
        if (selectedMeasurements.length === 0 && allMeasurements.length > 0) {
          selectedMeasurements = [allMeasurements[0]];
        }

        populateDropdown(measurementsDropdown, allMeasurements, selectedMeasurements, measurementDisplayFormatter);
        updateDropdownText(measurementsDropdown, allMeasurements, selectedMeasurements, measurementDisplayFormatter);
        
        // Ensure the measurements dropdown state is synchronized and chart/stats are updated
        // This fixes the issue where auto-selected measurements don't trigger chart updates
        onMeasurementsChange();
      } catch (err) {
        console.error('Failed to load measurements:', err);
        allMeasurements = [];
        selectedMeasurements = [];
        populateDropdown(measurementsDropdown, [], []);
        updateDropdownText(measurementsDropdown, [], [], measurementDisplayFormatter);
      }
    }

    // Update CSV and Excel form fields with current selections
    function updateCsvFields() {
      const csvBuckets = document.getElementById('csvBuckets');
      const csvMeasurements = document.getElementById('csvMeasurements');
      const excelBuckets = document.getElementById('excelBuckets');
      const excelMeasurements = document.getElementById('excelMeasurements');
      
      if (csvBuckets) csvBuckets.value = selectedBuckets.join(',');
      if (csvMeasurements) csvMeasurements.value = selectedMeasurements.join(',');
      if (excelBuckets) excelBuckets.value = selectedBuckets.join(',');
      if (excelMeasurements) excelMeasurements.value = selectedMeasurements.join(',');
    }

    // Update time range fields for both CSV and Excel forms
    function updateTimeFields(range, start, stop) {
      if (csvRange) csvRange.value = range || '';
      if (csvStart) csvStart.value = start || '';
      if (csvStop) csvStop.value = stop || '';
      if (excelRange) excelRange.value = range || '';
      if (excelStart) excelStart.value = start || '';
      if (excelStop) excelStop.value = stop || '';
    }

    // Show notification when no data is found
    function showNoDataNotification() {
      const chartContainer = document.querySelector('.chart-card');
      chartContainer.innerHTML = `
        <div style="text-align: center; padding: var(--md-spacing-xl);">
          <div style="color: var(--md-on-surface-variant); font-size: var(--md-font-size-h6); margin-bottom: var(--md-spacing-md);">
            üìä No Data Available
          </div>
          <p style="color: var(--md-on-surface-variant); font-size: var(--md-font-size-body1); margin: 0;">
            No sensor data was found for the selected time range and measurements.
          </p>
        </div>
      `;
      
      // Clear statistics table
      const statsTable = document.getElementById('stats-table').querySelector('tbody');
      statsTable.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--md-on-surface-variant);">No data available</td></tr>';
    }

    // Show error notification
    function showErrorNotification(message) {
      const chartContainer = document.querySelector('.chart-card');
      chartContainer.innerHTML = `
        <div style="text-align: center; padding: var(--md-spacing-xl);">
          <div style="color: var(--md-error); font-size: var(--md-font-size-h6); margin-bottom: var(--md-spacing-md);">
            ‚ö†Ô∏è Unable to Load Data
          </div>
          <p style="color: var(--md-on-surface-variant); font-size: var(--md-font-size-body1); margin: 0;">
            ${message}
          </p>
        </div>
      `;
      
      // Clear statistics table
      const statsTable = document.getElementById('stats-table').querySelector('tbody');
      statsTable.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--md-error);">Unable to load data</td></tr>';
    }

    // Toggle Modes
    btnRel.onclick = () => {
      btnRel.classList.remove('md-button-outlined');
      btnRel.classList.add('md-button-filled');
      btnAbs.classList.remove('md-button-filled');
      btnAbs.classList.add('md-button-outlined');
      relCtrls.style.display = 'flex';
      rangeInput.style.display = 'none';
      loadAndRender();
    };
    btnAbs.onclick = () => {
      btnRel.classList.remove('md-button-filled');
      btnRel.classList.add('md-button-outlined');
      btnAbs.classList.remove('md-button-outlined');
      btnAbs.classList.add('md-button-filled');
      relCtrls.style.display = 'none';
      rangeInput.style.display = 'inline-block';
    };

    // Quick-range Buttons
    relCtrls.querySelectorAll('[data-range]').forEach(btn => {
      btn.onclick = () => {
        currentRange = btn.dataset.range;
        relCtrls.querySelectorAll('.md-button').forEach(b => {
          b.classList.remove('md-button-filled');
          b.classList.add('md-button-outlined');
        });
        btn.classList.remove('md-button-outlined');
        btn.classList.add('md-button-filled');
        updateTimeFields(btn.dataset.range, '', '');
        loadAndRender();
      };
    });

    // Initialize Flatpickr for range selection (only if available)
    if (typeof flatpickr !== 'undefined') {
      flatpickr(rangeInput, {
        mode: 'range',
        enableTime: true,
        dateFormat: 'Y-m-d H:i',
        onClose: function(selectedDates) {
          if (selectedDates.length === 2) {
            const [start, stop] = selectedDates;
            updateTimeFields('', start.toISOString(), stop.toISOString());

            loadAndRender({
              start: start.toISOString(),
              stop:  stop.toISOString()
            });
          }
        }
      });
    } else {
      // Disable calendar mode if flatpickr is not available
      btnAbs.disabled = true;
      btnAbs.style.opacity = '0.5';
      btnAbs.style.cursor = 'not-allowed';
    }

    // Refresh button functionality
    refreshBtn.onclick = () => {
      if (selectedMeasurements.length > 0) {
        loadAndRender();
      }
    };


    // Fetch & Render Chart
    async function loadAndRender({ start, stop } = {}) {
      if (selectedMeasurements.length === 0) {
        return;
      }

      // Use selectedMeasurements directly to preserve bucket:measurement relationships
      // Extract buckets for the URL parameter, but send measurements with their bucket prefixes
      const bucketsSet = new Set();
      selectedMeasurements.forEach(val => {
        if (val.includes(':')) {
          const [bucket] = val.split(':', 2);
          bucketsSet.add(bucket);
        }
      });
      const bucketsArr = Array.from(bucketsSet);

      let url = `/api/sensors?limit=5000`;
      if (bucketsArr.length > 0) {
        url += `&buckets=${encodeURIComponent(bucketsArr.join(','))}`;
      } else if (selectedBuckets.length > 0) {
        url += `&buckets=${encodeURIComponent(selectedBuckets.join(','))}`;
      }
      
      // Send measurements with bucket prefixes to maintain relationships
      url += `&measurements=${encodeURIComponent(selectedMeasurements.join(','))}`;

      if (start && stop) {
        url += `&start=${encodeURIComponent(start)}&stop=${encodeURIComponent(stop)}`;
        updateTimeFields('', start.toISOString(), stop.toISOString());
      } else {
        url += `&range=${currentRange}`;
        updateTimeFields(currentRange, '', '');
      }

      updateCsvFields();

      try {
        const res = await fetch(url);
        
        if (!res.ok) {
          throw new Error(`API returned ${res.status}: ${res.statusText}`);
        }
        
        const data = await res.json();
        
        // Check if there's an error in the response
        if (data.error) {
          throw new Error(data.error);
        }
        
        const readings = data.readings || [];
        
        // Check if no data was returned
        if (readings.length === 0) {
          // Show no data notification
          showNoDataNotification();
          return;
        }

        // Group readings by bucket:measurement for charting
        const datasetsByMeasurement = {};
        readings.forEach(reading => {
          // Use bucket:measurement as key for uniqueness
          const key = (reading.bucket && reading.measurement) ? `${reading.bucket}:${reading.measurement}` : (reading.measurement || 'Unknown');
          if (!datasetsByMeasurement[key]) {
            datasetsByMeasurement[key] = {
              timestamps: [],
              values: []
            };
          }
          datasetsByMeasurement[key].timestamps.push(reading.timestamp);
          datasetsByMeasurement[key].values.push(reading.value);
        });

        // Create datasets for chart, show label as bucket (measurement)
        const datasets = Object.keys(datasetsByMeasurement).map((measurement, index) => {
          const colors = [
            '#1e88e5', '#e53935', '#43a047', '#fb8c00',
            '#8e24aa', '#00acc1', '#fdd835', '#f4511e'
          ];
          const color = colors[index % colors.length];
          // Convert hex to rgba for background
          const hex = color.slice(1);
          const r = parseInt(hex.slice(0, 2), 16);
          const g = parseInt(hex.slice(2, 4), 16);
          const b = parseInt(hex.slice(4, 6), 16);
          const backgroundColor = `rgba(${r}, ${g}, ${b}, 0.2)`;
          let label = measurement;
          if (measurement.includes(':')) {
            const [bucket, m] = measurement.split(':', 2);
            label = `${bucket} (${m})`;
          }
          return {
            label: label,
            data: datasetsByMeasurement[measurement].values,
            borderColor: color,
            backgroundColor: backgroundColor,
            fill: false,
            tension: 0.3
          };
        });

        // Use timestamps from first dataset for labels (assuming all have similar timestamps)
        const labels = Object.keys(datasetsByMeasurement).length > 0
          ? Object.values(datasetsByMeasurement)[0].timestamps.map(t => new Date(t).toLocaleString())
          : [];

        // Enhanced Chart rendering - use EnhancedChart if available, fallback to others
        if (typeof EnhancedChart !== 'undefined') {
          // Use enhanced chart implementation with all advanced features
          if (chart) {
            chart.data.labels = labels;
            chart.data.datasets = datasets;
            chart.update();
          } else {
            const ctx = document.getElementById('sensorChart').getContext('2d');
            chart = new EnhancedChart(ctx, {
              type: 'line',
              data: {
                labels,
                datasets
              },
              options: {
                responsive: true,
                maintainAspectRatio: false
              }
            });
            
            // Show chart controls when enhanced chart is available
            document.getElementById('chart-controls').style.display = 'flex';
            initializeChartControls();
          }
        } else if (typeof Chart !== 'undefined') {
          // Use Chart.js with basic functionality
          if (chart) {
            chart.data.labels = labels;
            chart.data.datasets = datasets;
            chart.update();
          } else {
            const ctx = document.getElementById('sensorChart').getContext('2d');
            chart = new Chart(ctx, {
              type: 'line',
              data: {
                labels,
                datasets
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: {
                    title: { display: true, text: 'Time' }
                  },
                  y: {
                    title: { display: true, text: 'Value' }
                  }
                },
                plugins: {
                  legend: {
                    display: true,
                    position: 'top'
                  }
                }
              }
            });
          }
        } else if (typeof FallbackChart !== 'undefined') {
          // Use fallback chart implementation
          if (chart) {
            chart.data.labels = labels;
            chart.data.datasets = datasets;
            chart.update();
          } else {
            const ctx = document.getElementById('sensorChart').getContext('2d');
            chart = new FallbackChart(ctx, {
              type: 'line',
              data: {
                labels,
                datasets
              },
              options: {
                responsive: true,
                maintainAspectRatio: false
              }
            });
          }
        } else {
          // Display message when no chart implementation is available
          const chartContainer = document.querySelector('.chart-card');
          chartContainer.innerHTML = '<p style="text-align: center; color: var(--md-on-surface-variant); font-size: var(--md-font-size-body1);">Chart display requires Chart.js library to be loaded.</p>';
        }
        
        // Update chart status
        updateChartStatus('success', 'Chart updated successfully');

        // --- Statistics Table ---
        const statsTable = document.getElementById('stats-table').querySelector('tbody');
        statsTable.innerHTML = '';
        Object.keys(datasetsByMeasurement).forEach(measurement => {
          const values = datasetsByMeasurement[measurement].values;
          if (!values.length) return;
          const min = Math.min(...values);
          const max = Math.max(...values);
          const avg = values.reduce((a, b) => a + b, 0) / values.length;
          let label = measurement;
          if (measurement.includes(':')) {
            const [bucket, m] = measurement.split(':', 2);
            label = `${bucket} (${m})`;
          }
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${label}</td>
            <td>${min.toFixed(2)}</td>
            <td>${avg.toFixed(2)}</td>
            <td>${max.toFixed(2)}</td>
          `;
          statsTable.appendChild(row);
        });
        // --- End Statistics Table ---

      } catch (err) {
        console.error('Failed to load sensor data:', err);
        showErrorNotification(err.message || 'Failed to load sensor data');
        updateChartStatus('error', 'Failed to load data');
      }
    }

    // Initialize enhanced chart controls
    function initializeChartControls() {
      if (!chart || typeof chart.setChartType !== 'function') return;

      // Chart type buttons
      document.querySelectorAll('.chart-type-button').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.chart-type-button').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          chart.setChartType(btn.dataset.type);
          updateChartStatus('success', 'Chart type changed to ' + btn.dataset.type);
        });
      });

      // Visual feature toggles
      document.getElementById('toggle-points').addEventListener('click', (e) => {
        e.target.classList.toggle('active');
        chart.setShowDataPoints(e.target.classList.contains('active'));
      });

      document.getElementById('toggle-fill').addEventListener('click', (e) => {
        e.target.classList.toggle('active');
        chart.setFillArea(e.target.classList.contains('active'));
      });

      document.getElementById('toggle-grid').addEventListener('click', (e) => {
        e.target.classList.toggle('active');
        chart.showGrid = e.target.classList.contains('active');
        chart.draw();
      });

      document.getElementById('toggle-legend').addEventListener('click', (e) => {
        e.target.classList.toggle('active');
        chart.showLegend = e.target.classList.contains('active');
        chart.draw();
      });

      // Line style buttons
      document.querySelectorAll('[data-line-style]').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('[data-line-style]').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          chart.setLineStyle(btn.dataset.lineStyle);
        });
      });

      // Color palette selection
      document.querySelectorAll('.color-palette-option').forEach(option => {
        option.addEventListener('click', () => {
          document.querySelectorAll('.color-palette-option').forEach(o => o.classList.remove('active'));
          option.classList.add('active');
          chart.setColorPalette(option.dataset.palette);
        });
      });

      // Y-axis type buttons
      document.querySelectorAll('[data-y-axis]').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('[data-y-axis]').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          chart.setYAxisType(btn.dataset.yAxis);
        });
      });

      // Zoom controls
      document.getElementById('zoom-in').addEventListener('click', () => {
        chart.zoom(1.2, chart.canvas.width / 2, chart.canvas.height / 2);
        updateZoomLevel();
      });

      document.getElementById('zoom-out').addEventListener('click', () => {
        chart.zoom(0.8, chart.canvas.width / 2, chart.canvas.height / 2);
        updateZoomLevel();
      });

      document.getElementById('reset-zoom').addEventListener('click', () => {
        chart.resetZoom();
        updateZoomLevel();
      });

      // Data processing toggles
      document.getElementById('toggle-smoothing').addEventListener('click', (e) => {
        e.target.classList.toggle('active');
        chart.setSmoothing(e.target.classList.contains('active'));
      });

      document.getElementById('toggle-moving-avg').addEventListener('click', (e) => {
        e.target.classList.toggle('active');
        const isActive = e.target.classList.contains('active');
        chart.setMovingAverage(isActive, parseInt(document.getElementById('ma-period').value));
        document.getElementById('ma-period-control').style.display = isActive ? 'block' : 'none';
      });

      // Moving average period control
      const maPeriodSlider = document.getElementById('ma-period');
      const maPeriodValue = document.getElementById('ma-period-value');
      
      maPeriodSlider.addEventListener('input', (e) => {
        const period = parseInt(e.target.value);
        maPeriodValue.textContent = period;
        if (document.getElementById('toggle-moving-avg').classList.contains('active')) {
          chart.setMovingAverage(true, period);
        }
      });

      // Export and utility actions
      document.getElementById('export-png').addEventListener('click', () => {
        chart.exportChart('png');
        updateChartStatus('success', 'Chart exported as PNG');
      });

      document.getElementById('fullscreen-chart').addEventListener('click', () => {
        chart.enterFullscreen();
      });

      // Update zoom level display
      function updateZoomLevel() {
        const zoomLevel = document.getElementById('zoom-level');
        if (chart.zoomLevel) {
          zoomLevel.textContent = `${Math.round(chart.zoomLevel * 100)}%`;
        }
      }

      // Initial state
      updateZoomLevel();
      updateChartStatus('success', 'Enhanced chart ready');
    }

    // Initial load
    loadBuckets();
  </script>
</body>
</html>
