<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Energy Dashboard</title>

  <!-- Flatpickr CSS for the calendar input -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
  />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css"
  />

  <style>
    :root {
      --primary-color: #0044cc;
      --accent-color: #0066ff;
      --bg-light: #f5f7fa;
      --text-color: #333;
      --shadow: rgba(0, 0, 0, 0.1);
    }

    /* Reset & base */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
      background: var(--bg-light);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Header */
    header {
      background: #fff;
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #e0e0e0;
      box-shadow: 0 2px 4px var(--shadow);
    }
    
    .header-left {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .logo img {
      width: 60px;
      height: auto;
    }
    
    .welcome-text {
      color: var(--primary-color);
      font-size: 1.5rem;
      font-weight: 600;
    }
    
    header form button {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    header form button:hover {
      background: var(--accent-color);
    }

    /* Controls Section */
    .controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 1rem 2rem;
      background: white;
      border-bottom: 1px solid #e0e0e0;
      flex-wrap: wrap;
      box-shadow: 0 1px 3px var(--shadow);
    }
    .btn {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn:hover { background: var(--accent-color); }
    .btn.active { background: #003399; }

    #relative-controls button { font-size: 0.9rem; }
    #rangePicker {
      padding: 0.5rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 220px;
      font-size: 0.95rem;
      display: none;
    }

    /* Chart Container */
    #chart-container {
      flex: 1;
      padding: 1rem 2rem;
      background: white;
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow);
    }
    #sensorChart {
      width: 100%;
      /*max-width: 1000px;*/
      height: 600px;
    }

    /* Time Range Controls Section */
    .time-range-section {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      background: #f8f9fa;
      margin-left: 1rem;
    }
    .time-range-section .section-label {
      font-weight: 600;
      color: var(--primary-color);
      margin-right: 0.5rem;
      font-size: 0.9rem;
    }
    .refresh-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
      font-size: 0.9rem;
      margin-left: 0.5rem;
    }
    .refresh-btn:hover {
      background: #218838;
    }

    /* Multi-select dropdowns */
    .dropdown-section {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-right: 1rem;
    }
    .dropdown-section label {
      font-weight: 500;
      min-width: fit-content;
    }
    .multi-select {
      min-width: 200px;
      max-width: 300px;
      padding: 0.5rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.95rem;
      background: white;
    }
    .multi-select:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(0, 68, 204, 0.2);
    }
  </style>
</head>
<body>

  <header>
    <div class="header-left">
      <div class="logo">
        <img src="/images/logo.jpg" alt="Company Logo">
      </div>
      <h1 class="welcome-text">Welcome, <%= user.username %> (<%= user.role %>)</h1>
    </div>
    <form method="POST" action="/logout">
      <button type="submit">Logout</button>
    </form>
  </header>

  <div class="controls">
    <!-- Bucket and Measurement Selection -->
    <div class="dropdown-section">
      <label for="bucketsSelect">Buckets:</label>
      <select id="bucketsSelect" class="multi-select" multiple>
        <option value="">Loading buckets...</option>
      </select>
    </div>
    
    <div class="dropdown-section">
      <label for="measurementsSelect">Measurements:</label>
      <select id="measurementsSelect" class="multi-select" multiple>
        <option value="">Select buckets first</option>
      </select>
    </div>

    <!-- Time Range Controls Section -->
    <div class="time-range-section">
      <span class="section-label">Time Range:</span>
      
      <!-- Mode toggles -->
      <button id="btn-relative" class="btn active">Relative</button>
      <button id="btn-absolute" class="btn">Calendar</button>

      <!-- Relative-range quick buttons -->
      <div id="relative-controls">
        <button class="btn" data-range="-5m">5 min</button>
        <button class="btn" data-range="-15m">15 min</button>
        <button class="btn" data-range="-30m">30 min</button>
        <button class="btn" data-range="-1h">1 hour</button>
        <button class="btn" data-range="-6h">6 hours</button>
        <button class="btn" data-range="-12h">12 hours</button>
        <button class="btn" data-range="-1d">1 day</button>
      </div>

      <!-- Flatpickr date-range input -->
      <input
        id="rangePicker"
        type="text"
        placeholder="Select date & time range"
        readonly
      />
      
      <!-- Refresh button -->
      <button id="refresh-btn" class="refresh-btn">ðŸ”„ Refresh</button>
    </div>

    <!-- CSV Export form -->
    <form method="GET" action="/export" class="export-form">
      <input type="hidden" name="range" id="csvRange" value="">
      <input type="hidden" name="start" id="csvStart" value="">
      <input type="hidden" name="stop" id="csvStop" value="">
      <input type="hidden" name="buckets" id="csvBuckets" value="">
      <input type="hidden" name="measurements" id="csvMeasurements" value="">
      <button type="submit" class="btn">Download CSV</button>
    </form>
   </div>

  </div>


  <div id="chart-container">
    <canvas id="sensorChart"></canvas>
  </div>

  <div id="stats-container" style="padding: 1rem 2rem; background: white; margin: 1rem; border-radius: 8px; box-shadow: 0 2px 8px var(--shadow);">
    <h3 style="color: var(--primary-color); margin-bottom: 1rem;">Statistics</h3>
    <table id="stats-table" style="width:100%; border-collapse: collapse;">
      <thead>
        <tr>
          <th style="border-bottom:1px solid #ccc; text-align:left; padding:0.5rem; color: var(--primary-color);">Measurement</th>
          <th style="border-bottom:1px solid #ccc; text-align:right; padding:0.5rem; color: var(--primary-color);">Min</th>
          <th style="border-bottom:1px solid #ccc; text-align:right; padding:0.5rem; color: var(--primary-color);">Avg</th>
          <th style="border-bottom:1px solid #ccc; text-align:right; padding:0.5rem; color: var(--primary-color);">Max</th>
        </tr>
      </thead>
      <tbody>
        <!-- Stats rows will be inserted here -->
      </tbody>
    </table>
  </div>

  <!-- Flatpickr & Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    // Elements
    const btnRel     = document.getElementById('btn-relative');
    const btnAbs     = document.getElementById('btn-absolute');
    const relCtrls   = document.getElementById('relative-controls');
    const refreshBtn = document.getElementById('refresh-btn');
    const csvRange = document.getElementById('csvRange');
    const csvStart = document.getElementById('csvStart');
    const csvStop  = document.getElementById('csvStop');
    const rangeInput = document.getElementById('rangePicker');
    const bucketsSelect = document.getElementById('bucketsSelect');
    const measurementsSelect = document.getElementById('measurementsSelect');

    let currentRange = '-1h';
    let chart;
    let selectedBuckets = [];
    let selectedMeasurements = [];

    // Load available buckets on page load
    async function loadBuckets() {
      try {
        const res = await fetch('/api/buckets');
        const { buckets } = await res.json();
        
        bucketsSelect.innerHTML = '';
        if (buckets.length === 0) {
          bucketsSelect.innerHTML = '<option value="">No buckets available</option>';
          return;
        }
        
        buckets.forEach(bucket => {
          const option = document.createElement('option');
          option.value = bucket;
          option.textContent = bucket;
          bucketsSelect.appendChild(option);
        });
        
        // Auto-select first bucket if available
        if (buckets.length > 0) {
          bucketsSelect.options[0].selected = true;
          selectedBuckets = [buckets[0]];
          await loadMeasurements();
        }
      } catch (err) {
        console.error('Failed to load buckets:', err);
        bucketsSelect.innerHTML = '<option value="">Error loading buckets</option>';
      }
    }

    // Load measurements for selected buckets
    async function loadMeasurements() {
      if (selectedBuckets.length === 0) {
        measurementsSelect.innerHTML = '<option value="">Select buckets first</option>';
        return;
      }
      
      try {
        const bucketsParam = selectedBuckets.join(',');
        const res = await fetch(`/api/measurements?buckets=${encodeURIComponent(bucketsParam)}`);
        const { measurements } = await res.json();

        measurementsSelect.innerHTML = '';
        if (measurements.length === 0) {
          measurementsSelect.innerHTML = '<option value="">No measurements available</option>';
          return;
        }

        // Show user-friendly label: bucket:measurement -> bucket (measurement)
        measurements.forEach(measurement => {
          const option = document.createElement('option');
          option.value = measurement;
          if (measurement.includes(':')) {
            const [bucket, m] = measurement.split(':', 2);
            option.textContent = `${bucket} (${m})`;
          } else {
            option.textContent = measurement;
          }
          measurementsSelect.appendChild(option);
        });

        // Auto-select first measurement if available
        if (measurements.length > 0) {
          measurementsSelect.options[0].selected = true;
          selectedMeasurements = [measurements[0]];
          loadAndRender();
        }
      } catch (err) {
        console.error('Failed to load measurements:', err);
        measurementsSelect.innerHTML = '<option value="">Error loading measurements</option>';
      }
    }

    // Handle bucket selection changes
    bucketsSelect.addEventListener('change', () => {
      selectedBuckets = Array.from(bucketsSelect.selectedOptions).map(option => option.value);
      selectedMeasurements = []; // Reset measurements when buckets change
      updateCsvFields();
      loadMeasurements();
    });

    // Handle measurement selection changes
    measurementsSelect.addEventListener('change', () => {
      selectedMeasurements = Array.from(measurementsSelect.selectedOptions).map(option => option.value);
      updateCsvFields();
      if (selectedMeasurements.length > 0) {
        loadAndRender();
      }
    });

    // Update CSV form fields with current selections
    function updateCsvFields() {
      const csvBuckets = document.getElementById('csvBuckets');
      const csvMeasurements = document.getElementById('csvMeasurements');
      if (csvBuckets) csvBuckets.value = selectedBuckets.join(',');
      if (csvMeasurements) csvMeasurements.value = selectedMeasurements.join(',');
    }

    // Toggle Modes
    btnRel.onclick = () => {
      btnRel.classList.add('active');
      btnAbs.classList.remove('active');
      relCtrls.style.display = 'flex';
      rangeInput.style.display = 'none';
      loadAndRender();
    };
    btnAbs.onclick = () => {
      btnRel.classList.remove('active');
      btnAbs.classList.add('active');
      relCtrls.style.display = 'none';
      rangeInput.style.display = 'inline-block';
    };

    // Quick-range Buttons
    relCtrls.querySelectorAll('[data-range]').forEach(btn => {
      btn.onclick = () => {
        currentRange = btn.dataset.range;
        relCtrls.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        csvRange.value = btn.dataset.range;
        csvStart.value = '';
        csvStop.value = '';
        loadAndRender();
      };
    });

    // Initialize Flatpickr for range selection
    flatpickr(rangeInput, {
      mode: 'range',
      enableTime: true,
      dateFormat: 'Y-m-d H:i',
      onClose: function(selectedDates) {
        if (selectedDates.length === 2) {
          const [start, stop] = selectedDates;
          csvStart.value = start.toISOString();
          csvStop.value  = stop.toISOString();
          csvRange.value = '';

          loadAndRender({
            start: start.toISOString(),
            stop:  stop.toISOString()
          });
        }
      }
    });

    // Refresh button functionality
    refreshBtn.onclick = () => {
      if (selectedMeasurements.length > 0) {
        loadAndRender();
      }
    };


    // Fetch & Render Chart
    async function loadAndRender({ start, stop } = {}) {
      if (selectedMeasurements.length === 0) {
        return;
      }

      // Parse selectedMeasurements into buckets and measurements
      const bucketsSet = new Set();
      const measurementsList = [];
      selectedMeasurements.forEach(val => {
        if (val.includes(':')) {
          const [bucket, measurement] = val.split(':', 2);
          bucketsSet.add(bucket);
          measurementsList.push(measurement);
        } else {
          measurementsList.push(val);
        }
      });
      const bucketsArr = Array.from(bucketsSet);

      let url = `/api/sensors?limit=5000`;
      if (bucketsArr.length > 0) {
        url += `&buckets=${encodeURIComponent(bucketsArr.join(','))}`;
      } else if (selectedBuckets.length > 0) {
        url += `&buckets=${encodeURIComponent(selectedBuckets.join(','))}`;
      }
      url += `&measurements=${encodeURIComponent(measurementsList.join(','))}`;

      if (start && stop) {
        url += `&start=${encodeURIComponent(start)}&stop=${encodeURIComponent(stop)}`;
        csvStart.value = start.toISOString();
        csvStop.value  = stop.toISOString();
        csvRange.value = '';
      } else {
        url += `&range=${currentRange}`;
        csvRange.value = currentRange;
        csvStart.value = '';
        csvStop.value = '';
      }

      updateCsvFields();

      try {
        const res = await fetch(url);
        const { readings } = await res.json();

        // Group readings by bucket:measurement for charting
        const datasetsByMeasurement = {};
        readings.forEach(reading => {
          // Use bucket:measurement as key for uniqueness
          const key = (reading.bucket && reading.measurement) ? `${reading.bucket}:${reading.measurement}` : (reading.measurement || 'Unknown');
          if (!datasetsByMeasurement[key]) {
            datasetsByMeasurement[key] = {
              timestamps: [],
              values: []
            };
          }
          datasetsByMeasurement[key].timestamps.push(reading.timestamp);
          datasetsByMeasurement[key].values.push(reading.value);
        });

        // Create datasets for chart, show label as bucket (measurement)
        const datasets = Object.keys(datasetsByMeasurement).map((measurement, index) => {
          const colors = [
            '#1e88e5', '#e53935', '#43a047', '#fb8c00',
            '#8e24aa', '#00acc1', '#fdd835', '#f4511e'
          ];
          const color = colors[index % colors.length];
          // Convert hex to rgba for background
          const hex = color.slice(1);
          const r = parseInt(hex.slice(0, 2), 16);
          const g = parseInt(hex.slice(2, 4), 16);
          const b = parseInt(hex.slice(4, 6), 16);
          const backgroundColor = `rgba(${r}, ${g}, ${b}, 0.2)`;
          let label = measurement;
          if (measurement.includes(':')) {
            const [bucket, m] = measurement.split(':', 2);
            label = `${bucket} (${m})`;
          }
          return {
            label: label,
            data: datasetsByMeasurement[measurement].values,
            borderColor: color,
            backgroundColor: backgroundColor,
            fill: false,
            tension: 0.3
          };
        });

        // Use timestamps from first dataset for labels (assuming all have similar timestamps)
        const labels = Object.keys(datasetsByMeasurement).length > 0
          ? Object.values(datasetsByMeasurement)[0].timestamps.map(t => new Date(t).toLocaleString())
          : [];

        if (chart) {
          chart.data.labels = labels;
          chart.data.datasets = datasets;
          chart.update();
        } else {
          const ctx = document.getElementById('sensorChart').getContext('2d');
          chart = new Chart(ctx, {
            type: 'line',
            data: {
              labels,
              datasets
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: {
                  title: { display: true, text: 'Time' }
                },
                y: {
                  title: { display: true, text: 'Value' }
                }
              },
              plugins: {
                legend: {
                  display: true,
                  position: 'top'
                }
              }
            }
          });
        }

        // --- Statistics Table ---
        const statsTable = document.getElementById('stats-table').querySelector('tbody');
        statsTable.innerHTML = '';
        Object.keys(datasetsByMeasurement).forEach(measurement => {
          const values = datasetsByMeasurement[measurement].values;
          if (!values.length) return;
          const min = Math.min(...values);
          const max = Math.max(...values);
          const avg = values.reduce((a, b) => a + b, 0) / values.length;
          let label = measurement;
          if (measurement.includes(':')) {
            const [bucket, m] = measurement.split(':', 2);
            label = `${bucket} (${m})`;
          }
          const row = document.createElement('tr');
          row.innerHTML = `
            <td style="padding:0.5rem;">${label}</td>
            <td style="padding:0.5rem; text-align:right;">${min.toFixed(2)}</td>
            <td style="padding:0.5rem; text-align:right;">${avg.toFixed(2)}</td>
            <td style="padding:0.5rem; text-align:right;">${max.toFixed(2)}</td>
          `;
          statsTable.appendChild(row);
        });
        // --- End Statistics Table ---

      } catch (err) {
        console.error('Failed to load sensor data:', err);
      }
    }

    // Initial load
    loadBuckets();
  </script>
</body>
</html>
