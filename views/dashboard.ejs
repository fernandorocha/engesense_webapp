<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Engesense - Energy Dashboard</title>
  
  <!-- Google Fonts - Roboto -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

  <!-- Flatpickr CSS for the calendar input -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
  />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css"
  />
  
  <!-- Material Design System -->
  <link rel="stylesheet" href="/css/design-system.css">

  <style>
    /* Dashboard-specific styles that complement the Material Design system */
    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Header styling with Material Design */
    .dashboard-header {
      background-color: var(--md-surface);
      border-bottom: 1px solid var(--md-outline);
      padding: var(--md-spacing-md) var(--md-spacing-lg);
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: var(--md-shadow-1);
    }
    
    .header-content {
      display: flex;
      align-items: center;
      gap: var(--md-spacing-lg);
    }
    
    .header-logo img {
      width: 60px;
      height: auto;
      border-radius: var(--md-radius-sm);
    }
    
    .welcome-text {
      color: var(--md-primary);
      font-size: var(--md-font-size-h5);
      font-weight: var(--md-font-weight-medium);
      margin: 0;
    }

    /* Controls Section */
    .controls-section {
      background-color: var(--md-surface);
      border-bottom: 1px solid var(--md-outline);
      padding: var(--md-spacing-lg);
      display: flex;
      flex-wrap: wrap;
      gap: var(--md-spacing-md);
      align-items: center;
      box-shadow: var(--md-shadow-1);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: var(--md-spacing-xs);
    }

    .control-label {
      font-size: var(--md-font-size-body2);
      font-weight: var(--md-font-weight-medium);
      color: var(--md-on-surface-variant);
      margin-bottom: var(--md-spacing-xs);
    }

    /* Dropdown styling */
    .dropdown-container {
      position: relative;
      min-width: 200px;
      max-width: 300px;
    }

    .dropdown-trigger {
      width: 100%;
      padding: var(--md-spacing-md);
      border: 1px solid var(--md-outline);
      border-radius: var(--md-radius-sm);
      background-color: var(--md-surface);
      color: var(--md-on-surface);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all var(--md-transition-fast);
      font-family: var(--md-font-family);
      font-size: var(--md-font-size-body1);
    }

    .dropdown-trigger:hover {
      border-color: var(--md-primary);
      background-color: var(--md-surface-variant);
    }

    .dropdown-trigger:focus {
      outline: none;
      border-color: var(--md-primary);
      box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.12);
    }

    .dropdown-content {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background-color: var(--md-surface);
      border: 1px solid var(--md-outline);
      border-radius: var(--md-radius-sm);
      box-shadow: var(--md-shadow-2);
      z-index: 1000;
      max-height: 250px;
      overflow-y: auto;
      margin-top: var(--md-spacing-xs);
      display: none;
    }

    .dropdown-content.open {
      display: block;
    }

    .dropdown-item {
      padding: var(--md-spacing-md);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: var(--md-spacing-sm);
      transition: background-color var(--md-transition-fast);
    }

    .dropdown-item:hover {
      background-color: var(--md-surface-variant);
    }

    /* Time Range Controls */
    .time-range-group {
      display: flex;
      align-items: center;
      gap: var(--md-spacing-sm);
      padding: var(--md-spacing-md);
      background-color: var(--md-surface-variant);
      border-radius: var(--md-radius-md);
      border: 1px solid var(--md-outline-variant);
    }

    .time-mode-buttons {
      display: flex;
      gap: var(--md-spacing-xs);
    }

    .time-quick-buttons {
      display: flex;
      gap: var(--md-spacing-xs);
      flex-wrap: wrap;
    }

    #rangePicker {
      display: none;
      min-width: 220px;
      padding: var(--md-spacing-sm);
      border: 1px solid var(--md-outline);
      border-radius: var(--md-radius-sm);
      background-color: var(--md-surface);
      color: var(--md-on-surface);
      font-family: var(--md-font-family);
    }

    /* Export section */
    .export-group {
      display: flex;
      gap: var(--md-spacing-sm);
      align-items: center;
    }

    /* Chart Container */
    .chart-section {
      flex: 1;
      padding: var(--md-spacing-lg);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .chart-card {
      width: 100%;
      max-width: 1200px;
      padding: var(--md-spacing-xl);
      min-height: 600px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #sensorChart {
      width: 100%;
      height: 600px;
    }

    /* Statistics Section */
    .stats-section {
      padding: 0 var(--md-spacing-lg) var(--md-spacing-lg);
    }

    .stats-card {
      padding: var(--md-spacing-xl);
    }

    .stats-title {
      color: var(--md-primary);
      margin-bottom: var(--md-spacing-lg);
      font-size: var(--md-font-size-h6);
      font-weight: var(--md-font-weight-medium);
    }

    .stats-table {
      width: 100%;
      border-collapse: collapse;
      font-size: var(--md-font-size-body2);
    }

    .stats-table th {
      background-color: var(--md-surface-variant);
      color: var(--md-primary);
      padding: var(--md-spacing-md);
      text-align: left;
      font-weight: var(--md-font-weight-medium);
      border-bottom: 2px solid var(--md-outline);
    }

    .stats-table td {
      padding: var(--md-spacing-md);
      border-bottom: 1px solid var(--md-outline-variant);
    }

    .stats-table th:not(:first-child),
    .stats-table td:not(:first-child) {
      text-align: right;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .controls-section {
        padding: var(--md-spacing-md);
        gap: var(--md-spacing-sm);
      }

      .control-group {
        width: 100%;
      }

      .dropdown-container {
        min-width: unset;
        width: 100%;
      }

      .time-range-group {
        flex-direction: column;
        align-items: stretch;
        gap: var(--md-spacing-md);
        width: 100%;
      }

      .time-quick-buttons {
        justify-content: center;
      }

      .export-group {
        width: 100%;
        justify-content: center;
      }

      .chart-card {
        padding: var(--md-spacing-lg);
        min-height: 400px;
      }

      #sensorChart {
        height: 400px;
      }

      .header-content {
        gap: var(--md-spacing-md);
      }

      .welcome-text {
        font-size: var(--md-font-size-body1);
      }
    }

    @media (max-width: 480px) {
      .dashboard-header {
        padding: var(--md-spacing-sm) var(--md-spacing-md);
      }

      .controls-section {
        padding: var(--md-spacing-sm);
      }

      .time-quick-buttons {
        gap: var(--md-spacing-xs);
      }

      .chart-card {
        padding: var(--md-spacing-md);
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="dashboard-header">
    <div class="header-content">
      <div class="header-logo">
        <img src="/images/logo.jpg" alt="Engesense Logo">
      </div>
      <h1 class="welcome-text">Welcome, <%= user.username %> (<%= user.role %>)</h1>
    </div>
    
    <div style="display: flex; align-items: center; gap: var(--md-spacing-md);">
      <% if (user.role === 'admin') { %>
        <a href="/admin/users" class="md-button md-button-outlined md-button-small">
          <span class="md-icon md-icon-sm">👥</span>
          Manage Users
        </a>
      <% } %>
      
      <form method="POST" action="/logout">
        <button type="submit" class="md-button md-button-text">
          <span class="md-icon md-icon-sm">🚪</span>
          Logout
        </button>
      </form>
    </div>
  </header>

  <!-- Controls Section -->
  <div class="controls-section">
    <!-- Bucket Selection -->
    <div class="control-group">
      <label class="control-label">Data Sources</label>
      <div class="dropdown-container" id="bucketsDropdown">
        <div class="dropdown-trigger" tabindex="0">
          <span class="dropdown-text">Loading buckets...</span>
          <span class="dropdown-arrow">▼</span>
        </div>
        <div class="dropdown-content">
          <!-- Options will be populated dynamically -->
        </div>
      </div>
    </div>
    
    <!-- Measurement Selection -->
    <div class="control-group">
      <label class="control-label">Measurements</label>
      <div class="dropdown-container" id="measurementsDropdown">
        <div class="dropdown-trigger" tabindex="0">
          <span class="dropdown-text">Select buckets first</span>
          <span class="dropdown-arrow">▼</span>
        </div>
        <div class="dropdown-content">
          <!-- Options will be populated dynamically -->
        </div>
      </div>
    </div>

    <!-- Time Range Controls -->
    <div class="control-group">
      <label class="control-label">Time Range</label>
      <div class="time-range-group">
        <!-- Mode toggles -->
        <div class="time-mode-buttons">
          <button id="btn-relative" class="md-button md-button-filled md-button-small">Relative</button>
          <button id="btn-absolute" class="md-button md-button-outlined md-button-small">Calendar</button>
        </div>

        <!-- Relative-range quick buttons -->
        <div id="relative-controls" class="time-quick-buttons">
          <button class="md-button md-button-outlined md-button-small" data-range="-5m">5 min</button>
          <button class="md-button md-button-outlined md-button-small" data-range="-15m">15 min</button>
          <button class="md-button md-button-outlined md-button-small" data-range="-30m">30 min</button>
          <button class="md-button md-button-outlined md-button-small" data-range="-1h">1 hour</button>
          <button class="md-button md-button-outlined md-button-small" data-range="-6h">6 hours</button>
          <button class="md-button md-button-outlined md-button-small" data-range="-12h">12 hours</button>
          <button class="md-button md-button-outlined md-button-small" data-range="-1d">1 day</button>
        </div>

        <!-- Flatpickr date-range input -->
        <input
          id="rangePicker"
          type="text"
          placeholder="Select date & time range"
          readonly
        />
        
        <!-- Refresh button -->
        <button id="refresh-btn" class="md-button md-button-filled md-button-small" style="background-color: var(--md-success);">
          <span class="md-icon md-icon-sm">🔄</span>
          Refresh
        </button>
        
        <!-- Demo button for testing chart -->
        <button id="demo-btn" class="md-button md-button-outlined md-button-small" style="border-color: var(--md-primary); color: var(--md-primary);">
          <span class="md-icon md-icon-sm">📊</span>
          Demo Data
        </button>
      </div>
    </div>

    <!-- Export section -->
    <div class="control-group">
      <label class="control-label">Export Data</label>
      <div class="export-group">
        <form method="GET" action="/export" class="export-form">
          <input type="hidden" name="range" id="csvRange" value="">
          <input type="hidden" name="start" id="csvStart" value="">
          <input type="hidden" name="stop" id="csvStop" value="">
          <input type="hidden" name="buckets" id="csvBuckets" value="">
          <input type="hidden" name="measurements" id="csvMeasurements" value="">
          <input type="hidden" name="format" value="csv">
          <button type="submit" class="md-button md-button-outlined md-button-small">
            <span class="md-icon md-icon-sm">📄</span>
            CSV
          </button>
        </form>
        
        <form method="GET" action="/export" class="export-form">
          <input type="hidden" name="range" id="excelRange" value="">
          <input type="hidden" name="start" id="excelStart" value="">
          <input type="hidden" name="stop" id="excelStop" value="">
          <input type="hidden" name="buckets" id="excelBuckets" value="">
          <input type="hidden" name="measurements" id="excelMeasurements" value="">
          <input type="hidden" name="format" value="excel">
          <button type="submit" class="md-button md-button-outlined md-button-small" style="color: var(--md-success); border-color: var(--md-success);">
            <span class="md-icon md-icon-sm">📊</span>
            Excel
          </button>
        </form>
      </div>
    </div>
  </div>

  <!-- Chart Section -->
  <div class="chart-section">
    <div class="md-card chart-card md-elevation-2">
      <div id="sensorChart"></div>
    </div>
  </div>

  <!-- Statistics Section -->
  <div class="stats-section">
    <div class="md-card stats-card md-elevation-1">
      <h3 class="stats-title">Statistics Summary</h3>
      <table class="stats-table" id="stats-table">
        <thead>
          <tr>
            <th>Measurement</th>
            <th>Minimum</th>
            <th>Average</th>
            <th>Maximum</th>
          </tr>
        </thead>
        <tbody>
          <!-- Stats rows will be inserted here -->
        </tbody>
      </table>
    </div>
  </div>

  <!-- Scripts -->
  <script src="/css/theme-system.js"></script>

  <!-- Fallback chart implementation when external dependencies are not available -->
  <script src="/js/fallback-chart.js"></script>

  <script>
    // Elements
    const btnRel     = document.getElementById('btn-relative');
    const btnAbs     = document.getElementById('btn-absolute');
    const relCtrls   = document.getElementById('relative-controls');
    const refreshBtn = document.getElementById('refresh-btn');
    const csvRange = document.getElementById('csvRange');
    const csvStart = document.getElementById('csvStart');
    const csvStop  = document.getElementById('csvStop');
    const excelRange = document.getElementById('excelRange');
    const excelStart = document.getElementById('excelStart');
    const excelStop  = document.getElementById('excelStop');
    const rangeInput = document.getElementById('rangePicker');
    const bucketsDropdown = document.getElementById('bucketsDropdown');
    const measurementsDropdown = document.getElementById('measurementsDropdown');

    let currentRange = '-1h';
    let chart;
    let selectedBuckets = [];
    let selectedMeasurements = [];

    // Display formatter for measurements: bucket:measurement -> bucket (measurement)
    const measurementDisplayFormatter = (measurement) => {
      if (measurement.includes(':')) {
        const [bucket, m] = measurement.split(':', 2);
        return `${bucket} (${m})`;
      }
      return measurement;
    };

    // Custom dropdown functionality
    function initializeDropdown(dropdownElement, onSelectionChange) {
      const trigger = dropdownElement.querySelector('.dropdown-trigger');
      const content = dropdownElement.querySelector('.dropdown-content');
      const textElement = trigger.querySelector('.dropdown-text');

      // Toggle dropdown
      trigger.addEventListener('click', () => {
        const isOpen = content.classList.contains('open');
        closeAllDropdowns();
        if (!isOpen) {
          content.classList.add('open');
          trigger.classList.add('open');
        }
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!dropdownElement.contains(e.target)) {
          content.classList.remove('open');
          trigger.classList.remove('open');
        }
      });

      // Handle checkbox changes
      content.addEventListener('change', (e) => {
        if (e.target.type === 'checkbox') {
          onSelectionChange();
        }
      });

      return { trigger, content, textElement };
    }

    function closeAllDropdowns() {
      document.querySelectorAll('.dropdown-content.open').forEach(content => {
        content.classList.remove('open');
      });
      document.querySelectorAll('.dropdown-trigger.open').forEach(trigger => {
        trigger.classList.remove('open');
      });
    }

    function updateDropdownText(dropdownElement, items, selectedItems, displayFormatter = null) {
      const textElement = dropdownElement.querySelector('.dropdown-text');
      if (selectedItems.length === 0) {
        // Special case for measurements dropdown when no buckets are selected
        if (dropdownElement.id === 'measurementsDropdown' && getAllBuckets().length === 0) {
          textElement.textContent = 'No buckets available';
        } else if (dropdownElement.id === 'measurementsDropdown' && selectedBuckets.length === 0) {
          textElement.textContent = 'Select buckets first';
        } else {
          textElement.textContent = items.length === 0 ? 'No items available' : 'Select items...';
        }
      } else if (selectedItems.length === 1) {
        const displayText = displayFormatter ? displayFormatter(selectedItems[0]) : selectedItems[0];
        textElement.textContent = displayText;
      } else {
        textElement.textContent = `${selectedItems.length} items selected`;
      }
    }

    function populateDropdown(dropdownElement, items, selectedItems, displayFormatter = null) {
      const content = dropdownElement.querySelector('.dropdown-content');
      content.innerHTML = '';

      if (items.length === 0) {
        content.innerHTML = '<div class="dropdown-item">No items available</div>';
        return;
      }

      items.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'dropdown-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = item;
        checkbox.checked = selectedItems.includes(item);
        
        const label = document.createElement('label');
        label.textContent = displayFormatter ? displayFormatter(item) : item;
        label.style.cursor = 'pointer';
        label.style.marginLeft = '0.25rem';
        
        itemDiv.appendChild(checkbox);
        itemDiv.appendChild(label);
        
        // Make the whole item clickable
        itemDiv.addEventListener('click', (e) => {
          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        
        content.appendChild(itemDiv);
      });
    }

    // Initialize dropdowns with improved state management
    const bucketsDropdownControls = initializeDropdown(bucketsDropdown, () => {
      const checkboxes = bucketsDropdown.querySelectorAll('input[type="checkbox"]:checked');
      const newSelectedBuckets = Array.from(checkboxes).map(cb => cb.value);
      
      // Only update if the selection actually changed to avoid unnecessary API calls
      if (JSON.stringify(newSelectedBuckets) !== JSON.stringify(selectedBuckets)) {
        selectedBuckets = newSelectedBuckets;
        updateDropdownText(bucketsDropdown, getAllBuckets(), selectedBuckets);
        updateCsvFields();
        loadMeasurements();
      }
    });

    // Define the measurements onChange handler with improved state management
    function onMeasurementsChange() {
      const checkboxes = measurementsDropdown.querySelectorAll('input[type="checkbox"]:checked');
      const newSelectedMeasurements = Array.from(checkboxes).map(cb => cb.value);
      
      // Only update if the selection actually changed to avoid unnecessary API calls
      if (JSON.stringify(newSelectedMeasurements) !== JSON.stringify(selectedMeasurements)) {
        selectedMeasurements = newSelectedMeasurements;
        updateDropdownText(measurementsDropdown, getAllMeasurements(), selectedMeasurements, measurementDisplayFormatter);
        updateCsvFields();
        if (selectedMeasurements.length > 0) {
          loadAndRender();
        }
      }
    }
    
    const measurementsDropdownControls = initializeDropdown(measurementsDropdown, onMeasurementsChange);

    let allBuckets = [];
    let allMeasurements = [];

    function getAllBuckets() { return allBuckets; }
    function getAllMeasurements() { return allMeasurements; }

    // Load available buckets on page load
    async function loadBuckets() {
      try {
        const res = await fetch('/api/buckets');
        
        if (!res.ok) {
          console.error('Failed to load buckets: API returned error');
          // When buckets fail to load, clear state and ensure dropdown is properly initialized
          allBuckets = [];
          selectedBuckets = [];
          populateDropdown(bucketsDropdown, [], []);
          updateDropdownText(bucketsDropdown, [], []);
          
          // Clear measurements when buckets fail to load
          allMeasurements = [];
          selectedMeasurements = [];
          populateDropdown(measurementsDropdown, [], []);
          updateDropdownText(measurementsDropdown, [], [], measurementDisplayFormatter);
          return;
        }
        
        const data = await res.json();
        allBuckets = data.buckets || [];
        
        if (allBuckets.length === 0) {
          selectedBuckets = [];
          updateDropdownText(bucketsDropdown, [], []);
          // Clear measurements when no buckets are available
          allMeasurements = [];
          selectedMeasurements = [];
          populateDropdown(measurementsDropdown, [], []);
          updateDropdownText(measurementsDropdown, [], []);
          return;
        }
        
        populateDropdown(bucketsDropdown, allBuckets, selectedBuckets);
        updateDropdownText(bucketsDropdown, allBuckets, selectedBuckets);
        
        // Auto-select first bucket if available and none selected
        if (allBuckets.length > 0 && selectedBuckets.length === 0) {
          selectedBuckets = [allBuckets[0]];
          populateDropdown(bucketsDropdown, allBuckets, selectedBuckets);
          updateDropdownText(bucketsDropdown, allBuckets, selectedBuckets);
          await loadMeasurements();
        }
      } catch (err) {
        console.error('Failed to load buckets:', err);
        allBuckets = [];
        selectedBuckets = [];
        updateDropdownText(bucketsDropdown, [], []);
        // Clear measurements when buckets fail to load
        allMeasurements = [];
        selectedMeasurements = [];
        populateDropdown(measurementsDropdown, [], []);
        updateDropdownText(measurementsDropdown, [], []);
      }
    }

    // Load measurements for selected buckets
    async function loadMeasurements() {
      if (selectedBuckets.length === 0) {
        allMeasurements = [];
        selectedMeasurements = [];
        populateDropdown(measurementsDropdown, [], []);
        updateDropdownText(measurementsDropdown, [], [], measurementDisplayFormatter);
        return;
      }
      
      try {
        const bucketsParam = selectedBuckets.join(',');
        const res = await fetch(`/api/measurements?buckets=${encodeURIComponent(bucketsParam)}`);
        
        if (!res.ok) {
          console.error('Failed to load measurements: API returned error');
          allMeasurements = [];
          selectedMeasurements = [];
          populateDropdown(measurementsDropdown, [], []);
          updateDropdownText(measurementsDropdown, [], [], measurementDisplayFormatter);
          return;
        }
        
        const data = await res.json();
        const measurements = data.measurements || [];

        allMeasurements = measurements;
        
        // Filter selectedMeasurements to only include measurements that still exist
        // This preserves user selection when possible, but removes invalid selections
        selectedMeasurements = selectedMeasurements.filter(m => allMeasurements.includes(m));

        if (allMeasurements.length === 0) {
          selectedMeasurements = [];
          populateDropdown(measurementsDropdown, [], []);
          updateDropdownText(measurementsDropdown, [], [], measurementDisplayFormatter);
          return;
        }

        // Use display formatter for bucket:measurement -> bucket (measurement)
        // (Using global formatter instead of local)

        // Auto-select first measurement only if no valid selections remain
        if (selectedMeasurements.length === 0 && allMeasurements.length > 0) {
          selectedMeasurements = [allMeasurements[0]];
        }

        populateDropdown(measurementsDropdown, allMeasurements, selectedMeasurements, measurementDisplayFormatter);
        updateDropdownText(measurementsDropdown, allMeasurements, selectedMeasurements, measurementDisplayFormatter);
        
        // Ensure the measurements dropdown state is synchronized and chart/stats are updated
        // This fixes the issue where auto-selected measurements don't trigger chart updates
        onMeasurementsChange();
      } catch (err) {
        console.error('Failed to load measurements:', err);
        allMeasurements = [];
        selectedMeasurements = [];
        populateDropdown(measurementsDropdown, [], []);
        updateDropdownText(measurementsDropdown, [], [], measurementDisplayFormatter);
      }
    }

    // Update CSV and Excel form fields with current selections
    function updateCsvFields() {
      const csvBuckets = document.getElementById('csvBuckets');
      const csvMeasurements = document.getElementById('csvMeasurements');
      const excelBuckets = document.getElementById('excelBuckets');
      const excelMeasurements = document.getElementById('excelMeasurements');
      
      if (csvBuckets) csvBuckets.value = selectedBuckets.join(',');
      if (csvMeasurements) csvMeasurements.value = selectedMeasurements.join(',');
      if (excelBuckets) excelBuckets.value = selectedBuckets.join(',');
      if (excelMeasurements) excelMeasurements.value = selectedMeasurements.join(',');
    }

    // Update time range fields for both CSV and Excel forms
    function updateTimeFields(range, start, stop) {
      if (csvRange) csvRange.value = range || '';
      if (csvStart) csvStart.value = start || '';
      if (csvStop) csvStop.value = stop || '';
      if (excelRange) excelRange.value = range || '';
      if (excelStart) excelStart.value = start || '';
      if (excelStop) excelStop.value = stop || '';
    }

    // Show notification when no data is found
    function showNoDataNotification() {
      const chartContainer = document.querySelector('.chart-card');
      chartContainer.innerHTML = `
        <div style="text-align: center; padding: var(--md-spacing-xl);">
          <div style="color: var(--md-on-surface-variant); font-size: var(--md-font-size-h6); margin-bottom: var(--md-spacing-md);">
            📊 No Data Available
          </div>
          <p style="color: var(--md-on-surface-variant); font-size: var(--md-font-size-body1); margin: 0;">
            No sensor data was found for the selected time range and measurements.
          </p>
        </div>
      `;
      
      // Clear statistics table
      const statsTable = document.getElementById('stats-table').querySelector('tbody');
      statsTable.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--md-on-surface-variant);">No data available</td></tr>';
    }

    // Show error notification
    function showErrorNotification(message) {
      const chartContainer = document.querySelector('.chart-card');
      chartContainer.innerHTML = `
        <div style="text-align: center; padding: var(--md-spacing-xl);">
          <div style="color: var(--md-error); font-size: var(--md-font-size-h6); margin-bottom: var(--md-spacing-md);">
            ⚠️ Unable to Load Data
          </div>
          <p style="color: var(--md-on-surface-variant); font-size: var(--md-font-size-body1); margin: 0;">
            ${message}
          </p>
        </div>
      `;
      
      // Clear statistics table
      const statsTable = document.getElementById('stats-table').querySelector('tbody');
      statsTable.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--md-error);">Unable to load data</td></tr>';
    }

    // Toggle Modes
    btnRel.onclick = () => {
      btnRel.classList.remove('md-button-outlined');
      btnRel.classList.add('md-button-filled');
      btnAbs.classList.remove('md-button-filled');
      btnAbs.classList.add('md-button-outlined');
      relCtrls.style.display = 'flex';
      rangeInput.style.display = 'none';
      loadAndRender();
    };
    btnAbs.onclick = () => {
      btnRel.classList.remove('md-button-filled');
      btnRel.classList.add('md-button-outlined');
      btnAbs.classList.remove('md-button-outlined');
      btnAbs.classList.add('md-button-filled');
      relCtrls.style.display = 'none';
      rangeInput.style.display = 'inline-block';
    };

    // Quick-range Buttons
    relCtrls.querySelectorAll('[data-range]').forEach(btn => {
      btn.onclick = () => {
        currentRange = btn.dataset.range;
        relCtrls.querySelectorAll('.md-button').forEach(b => {
          b.classList.remove('md-button-filled');
          b.classList.add('md-button-outlined');
        });
        btn.classList.remove('md-button-outlined');
        btn.classList.add('md-button-filled');
        updateTimeFields(btn.dataset.range, '', '');
        loadAndRender();
      };
    });

    // Initialize Flatpickr for range selection (disabled - external dependency not available)
    // Disable calendar mode since flatpickr is not available
    btnAbs.disabled = true;
    btnAbs.style.opacity = '0.5';
    btnAbs.style.cursor = 'not-allowed';
    btnAbs.title = 'Calendar mode requires external dependencies';

    // Refresh button functionality
    refreshBtn.onclick = () => {
      if (selectedMeasurements.length > 0) {
        loadAndRender();
      }
    };

    // Demo button functionality
    const demoBtn = document.getElementById('demo-btn');
    demoBtn.onclick = () => {
      // Generate demo data to show chart functionality
      const demoDatasets = [
        {
          label: 'Temperature (°C)',
          data: [22.5, 23.1, 24.3, 25.7, 24.9, 23.8, 22.9, 23.4, 24.1, 23.7],
          borderColor: '#1e88e5'
        },
        {
          label: 'Humidity (%)',
          data: [45.2, 47.8, 49.1, 52.3, 48.7, 46.5, 44.9, 46.8, 48.2, 47.1],
          borderColor: '#e53935'
        },
        {
          label: 'Pressure (hPa)',
          data: [1013.2, 1014.1, 1012.8, 1011.5, 1013.9, 1015.2, 1014.7, 1013.4, 1012.1, 1014.8],
          borderColor: '#43a047'
        }
      ];
      
      // Update chart with demo data
      if (typeof FallbackChart !== 'undefined') {
        if (chart) {
          chart.updateData(demoDatasets);
        } else {
          const container = document.getElementById('sensorChart');
          chart = new FallbackChart(container);
          chart.updateData(demoDatasets);
          window.chart = chart;
        }
      }
      
      // Update statistics table with demo data
      const statsTable = document.getElementById('stats-table').querySelector('tbody');
      statsTable.innerHTML = '';
      demoDatasets.forEach(dataset => {
        const values = dataset.data;
        const min = Math.min(...values);
        const max = Math.max(...values);
        const avg = values.reduce((a, b) => a + b, 0) / values.length;
        
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${dataset.label}</td>
          <td>${min.toFixed(2)}</td>
          <td>${avg.toFixed(2)}</td>
          <td>${max.toFixed(2)}</td>
        `;
        statsTable.appendChild(row);
      });
    };


    // Fetch & Render Chart
    async function loadAndRender({ start, stop } = {}) {
      if (selectedMeasurements.length === 0) {
        return;
      }

      // Use selectedMeasurements directly to preserve bucket:measurement relationships
      // Extract buckets for the URL parameter, but send measurements with their bucket prefixes
      const bucketsSet = new Set();
      selectedMeasurements.forEach(val => {
        if (val.includes(':')) {
          const [bucket] = val.split(':', 2);
          bucketsSet.add(bucket);
        }
      });
      const bucketsArr = Array.from(bucketsSet);

      let url = `/api/sensors?limit=5000`;
      if (bucketsArr.length > 0) {
        url += `&buckets=${encodeURIComponent(bucketsArr.join(','))}`;
      } else if (selectedBuckets.length > 0) {
        url += `&buckets=${encodeURIComponent(selectedBuckets.join(','))}`;
      }
      
      // Send measurements with bucket prefixes to maintain relationships
      url += `&measurements=${encodeURIComponent(selectedMeasurements.join(','))}`;

      if (start && stop) {
        url += `&start=${encodeURIComponent(start)}&stop=${encodeURIComponent(stop)}`;
        updateTimeFields('', start.toISOString(), stop.toISOString());
      } else {
        url += `&range=${currentRange}`;
        updateTimeFields(currentRange, '', '');
      }

      updateCsvFields();

      try {
        const res = await fetch(url);
        
        if (!res.ok) {
          throw new Error(`API returned ${res.status}: ${res.statusText}`);
        }
        
        const data = await res.json();
        
        // Check if there's an error in the response
        if (data.error) {
          throw new Error(data.error);
        }
        
        const readings = data.readings || [];
        
        // Check if no data was returned
        if (readings.length === 0) {
          // Show no data notification
          showNoDataNotification();
          return;
        }

        // Group readings by bucket:measurement for charting
        const datasetsByMeasurement = {};
        readings.forEach(reading => {
          // Use bucket:measurement as key for uniqueness
          const key = (reading.bucket && reading.measurement) ? `${reading.bucket}:${reading.measurement}` : (reading.measurement || 'Unknown');
          if (!datasetsByMeasurement[key]) {
            datasetsByMeasurement[key] = {
              timestamps: [],
              values: []
            };
          }
          datasetsByMeasurement[key].timestamps.push(reading.timestamp);
          datasetsByMeasurement[key].values.push(reading.value);
        });

        // Create datasets for chart, show label as bucket (measurement)
        const datasets = Object.keys(datasetsByMeasurement).map((measurement, index) => {
          const colors = [
            '#1e88e5', '#e53935', '#43a047', '#fb8c00',
            '#8e24aa', '#00acc1', '#fdd835', '#f4511e'
          ];
          const color = colors[index % colors.length];
          // Convert hex to rgba for background
          const hex = color.slice(1);
          const r = parseInt(hex.slice(0, 2), 16);
          const g = parseInt(hex.slice(2, 4), 16);
          const b = parseInt(hex.slice(4, 6), 16);
          const backgroundColor = `rgba(${r}, ${g}, ${b}, 0.2)`;
          let label = measurement;
          if (measurement.includes(':')) {
            const [bucket, m] = measurement.split(':', 2);
            label = `${bucket} (${m})`;
          }
          return {
            label: label,
            data: datasetsByMeasurement[measurement].values,
            borderColor: color,
            backgroundColor: backgroundColor,
            fill: false,
            tension: 0.3
          };
        });

        // Use timestamps from first dataset for labels (assuming all have similar timestamps)
        const labels = Object.keys(datasetsByMeasurement).length > 0
          ? Object.values(datasetsByMeasurement)[0].timestamps.map(t => new Date(t).toLocaleString())
          : [];

        // Chart rendering using fallback chart implementation
        if (typeof FallbackChart !== 'undefined') {
          if (chart) {
            chart.updateData(datasets);
          } else {
            const container = document.getElementById('sensorChart');
            chart = new FallbackChart(container);
            chart.updateData(datasets);
            // Make chart globally accessible for resize handling
            window.chart = chart;
          }
        } else {
          // Display message when chart library is not available
          const chartContainer = document.querySelector('.chart-card');
          chartContainer.innerHTML = '<p style="text-align: center; color: var(--md-on-surface-variant); font-size: var(--md-font-size-body1);">Chart display library not available.</p>';
        }

        // --- Statistics Table ---
        const statsTable = document.getElementById('stats-table').querySelector('tbody');
        statsTable.innerHTML = '';
        Object.keys(datasetsByMeasurement).forEach(measurement => {
          const values = datasetsByMeasurement[measurement].values;
          if (!values.length) return;
          const min = Math.min(...values);
          const max = Math.max(...values);
          const avg = values.reduce((a, b) => a + b, 0) / values.length;
          let label = measurement;
          if (measurement.includes(':')) {
            const [bucket, m] = measurement.split(':', 2);
            label = `${bucket} (${m})`;
          }
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${label}</td>
            <td>${min.toFixed(2)}</td>
            <td>${avg.toFixed(2)}</td>
            <td>${max.toFixed(2)}</td>
          `;
          statsTable.appendChild(row);
        });
        // --- End Statistics Table ---

      } catch (err) {
        console.error('Failed to load sensor data:', err);
        showErrorNotification(err.message || 'Failed to load sensor data');
      }
    }

    // Initial load and chart initialization
    loadBuckets();
    
    // Initialize empty chart on page load
    if (typeof FallbackChart !== 'undefined') {
      const container = document.getElementById('sensorChart');
      chart = new FallbackChart(container);
      // Make chart globally accessible for resize handling
      window.chart = chart;
    }
  </script>
</body>
</html>
