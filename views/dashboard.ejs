<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Energy Dashboard</title>

  <!-- Flatpickr CSS for the calendar input -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
  />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css"
  />

  <style>
    :root {
      --primary-color: #0044cc;
      --accent-color: #0066ff;
      --bg-light: #f5f7fa;
      --text-color: #333;
      --shadow: rgba(0, 0, 0, 0.1);
    }

    /* Reset & base */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
      background: var(--bg-light);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Header */
    header {
      background: #fff;
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #e0e0e0;
      box-shadow: 0 2px 4px var(--shadow);
    }
    
    .header-left {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .logo img {
      width: 60px;
      height: auto;
    }
    
    .welcome-text {
      color: var(--primary-color);
      font-size: 1.5rem;
      font-weight: 600;
    }
    
    header form button {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    header form button:hover {
      background: var(--accent-color);
    }

    /* Controls Section */
    .controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 1rem 2rem;
      background: white;
      border-bottom: 1px solid #e0e0e0;
      flex-wrap: wrap;
      box-shadow: 0 1px 3px var(--shadow);
    }
    .btn {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn:hover { background: var(--accent-color); }
    .btn.active { background: #003399; }

    #relative-controls button { font-size: 0.9rem; }
    #rangePicker {
      padding: 0.5rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 220px;
      font-size: 0.95rem;
      display: none;
    }

    /* Chart Container */
    #chart-container {
      flex: 1;
      padding: 1rem 2rem;
      background: white;
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow);
    }
    #sensorChart {
      width: 100%;
      /*max-width: 1000px;*/
      height: 600px;
    }

    /* Time Range Controls Section */
    .time-range-section {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      background: #f8f9fa;
      margin-left: 1rem;
    }
    .time-range-section .section-label {
      font-weight: 600;
      color: var(--primary-color);
      margin-right: 0.5rem;
      font-size: 0.9rem;
    }
    .refresh-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
      font-size: 0.9rem;
      margin-left: 0.5rem;
    }
    .refresh-btn:hover {
      background: #218838;
    }

    /* Custom dropdown with checkboxes */
    .dropdown-section {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-right: 1rem;
    }
    .dropdown-section label {
      font-weight: 500;
      min-width: fit-content;
    }
    .custom-dropdown {
      position: relative;
      min-width: 200px;
      max-width: 300px;
    }
    .dropdown-trigger {
      padding: 0.5rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.95rem;
      background: white;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      min-height: 40px;
    }
    .dropdown-trigger:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(0, 68, 204, 0.2);
    }
    .dropdown-trigger:hover {
      border-color: var(--accent-color);
    }
    .dropdown-arrow {
      margin-left: 0.5rem;
      transition: transform 0.2s;
    }
    .dropdown-trigger.open .dropdown-arrow {
      transform: rotate(180deg);
    }
    .dropdown-content {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 4px 8px var(--shadow);
      z-index: 1000;
      max-height: 250px;
      overflow-y: auto;
      display: none;
    }
    .dropdown-content.open {
      display: block;
    }
    .dropdown-item {
      padding: 0.5rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .dropdown-item:hover {
      background: #f5f5f5;
    }
    .dropdown-item input[type="checkbox"] {
      margin: 0;
    }
    .dropdown-selected-count {
      color: #666;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>

  <header>
    <div class="header-left">
      <div class="logo">
        <img src="/images/logo.jpg" alt="Company Logo">
      </div>
      <h1 class="welcome-text">Welcome, <%= user.username %> (<%= user.role %>)</h1>
    </div>
    <form method="POST" action="/logout">
      <button type="submit">Logout</button>
    </form>
  </header>

  <div class="controls">
    <!-- Bucket and Measurement Selection -->
    <div class="dropdown-section">
      <label for="bucketsSelect">Buckets:</label>
      <div class="custom-dropdown" id="bucketsDropdown">
        <div class="dropdown-trigger" tabindex="0">
          <span class="dropdown-text">Loading buckets...</span>
          <span class="dropdown-arrow">â–¼</span>
        </div>
        <div class="dropdown-content">
          <!-- Options will be populated dynamically -->
        </div>
      </div>
    </div>
    
    <div class="dropdown-section">
      <label for="measurementsSelect">Measurements:</label>
      <div class="custom-dropdown" id="measurementsDropdown">
        <div class="dropdown-trigger" tabindex="0">
          <span class="dropdown-text">Select buckets first</span>
          <span class="dropdown-arrow">â–¼</span>
        </div>
        <div class="dropdown-content">
          <!-- Options will be populated dynamically -->
        </div>
      </div>
    </div>

    <!-- Time Range Controls Section -->
    <div class="time-range-section">
      <span class="section-label">Time Range:</span>
      
      <!-- Mode toggles -->
      <button id="btn-relative" class="btn active">Relative</button>
      <button id="btn-absolute" class="btn">Calendar</button>

      <!-- Relative-range quick buttons -->
      <div id="relative-controls">
        <button class="btn" data-range="-5m">5 min</button>
        <button class="btn" data-range="-15m">15 min</button>
        <button class="btn" data-range="-30m">30 min</button>
        <button class="btn" data-range="-1h">1 hour</button>
        <button class="btn" data-range="-6h">6 hours</button>
        <button class="btn" data-range="-12h">12 hours</button>
        <button class="btn" data-range="-1d">1 day</button>
      </div>

      <!-- Flatpickr date-range input -->
      <input
        id="rangePicker"
        type="text"
        placeholder="Select date & time range"
        readonly
      />
      
      <!-- Refresh button -->
      <button id="refresh-btn" class="refresh-btn">ðŸ”„ Refresh</button>
    </div>

    <!-- CSV Export form -->
    <form method="GET" action="/export" class="export-form">
      <input type="hidden" name="range" id="csvRange" value="">
      <input type="hidden" name="start" id="csvStart" value="">
      <input type="hidden" name="stop" id="csvStop" value="">
      <input type="hidden" name="buckets" id="csvBuckets" value="">
      <input type="hidden" name="measurements" id="csvMeasurements" value="">
      <button type="submit" class="btn">Download CSV</button>
    </form>
   </div>

  </div>


  <div id="chart-container">
    <canvas id="sensorChart"></canvas>
  </div>

  <div id="stats-container" style="padding: 1rem 2rem; background: white; margin: 1rem; border-radius: 8px; box-shadow: 0 2px 8px var(--shadow);">
    <h3 style="color: var(--primary-color); margin-bottom: 1rem;">Statistics</h3>
    <table id="stats-table" style="width:100%; border-collapse: collapse;">
      <thead>
        <tr>
          <th style="border-bottom:1px solid #ccc; text-align:left; padding:0.5rem; color: var(--primary-color);">Measurement</th>
          <th style="border-bottom:1px solid #ccc; text-align:right; padding:0.5rem; color: var(--primary-color);">Min</th>
          <th style="border-bottom:1px solid #ccc; text-align:right; padding:0.5rem; color: var(--primary-color);">Avg</th>
          <th style="border-bottom:1px solid #ccc; text-align:right; padding:0.5rem; color: var(--primary-color);">Max</th>
        </tr>
      </thead>
      <tbody>
        <!-- Stats rows will be inserted here -->
      </tbody>
    </table>
  </div>

  <!-- Flatpickr & Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    // Elements
    const btnRel     = document.getElementById('btn-relative');
    const btnAbs     = document.getElementById('btn-absolute');
    const relCtrls   = document.getElementById('relative-controls');
    const refreshBtn = document.getElementById('refresh-btn');
    const csvRange = document.getElementById('csvRange');
    const csvStart = document.getElementById('csvStart');
    const csvStop  = document.getElementById('csvStop');
    const rangeInput = document.getElementById('rangePicker');
    const bucketsDropdown = document.getElementById('bucketsDropdown');
    const measurementsDropdown = document.getElementById('measurementsDropdown');

    let currentRange = '-1h';
    let chart;
    let selectedBuckets = [];
    let selectedMeasurements = [];

    // Display formatter for measurements: bucket:measurement -> bucket (measurement)
    const measurementDisplayFormatter = (measurement) => {
      if (measurement.includes(':')) {
        const [bucket, m] = measurement.split(':', 2);
        return `${bucket} (${m})`;
      }
      return measurement;
    };

    // Custom dropdown functionality
    function initializeDropdown(dropdownElement, onSelectionChange) {
      const trigger = dropdownElement.querySelector('.dropdown-trigger');
      const content = dropdownElement.querySelector('.dropdown-content');
      const textElement = trigger.querySelector('.dropdown-text');

      // Toggle dropdown
      trigger.addEventListener('click', () => {
        const isOpen = content.classList.contains('open');
        closeAllDropdowns();
        if (!isOpen) {
          content.classList.add('open');
          trigger.classList.add('open');
        }
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!dropdownElement.contains(e.target)) {
          content.classList.remove('open');
          trigger.classList.remove('open');
        }
      });

      // Handle checkbox changes
      content.addEventListener('change', (e) => {
        if (e.target.type === 'checkbox') {
          onSelectionChange();
        }
      });

      return { trigger, content, textElement };
    }

    function closeAllDropdowns() {
      document.querySelectorAll('.dropdown-content.open').forEach(content => {
        content.classList.remove('open');
      });
      document.querySelectorAll('.dropdown-trigger.open').forEach(trigger => {
        trigger.classList.remove('open');
      });
    }

    function updateDropdownText(dropdownElement, items, selectedItems, displayFormatter = null) {
      const textElement = dropdownElement.querySelector('.dropdown-text');
      if (selectedItems.length === 0) {
        textElement.textContent = items.length === 0 ? 'No items available' : 'Select items...';
      } else if (selectedItems.length === 1) {
        const displayText = displayFormatter ? displayFormatter(selectedItems[0]) : selectedItems[0];
        textElement.textContent = displayText;
      } else {
        textElement.textContent = `${selectedItems.length} items selected`;
      }
    }

    function populateDropdown(dropdownElement, items, selectedItems, displayFormatter = null) {
      const content = dropdownElement.querySelector('.dropdown-content');
      content.innerHTML = '';

      if (items.length === 0) {
        content.innerHTML = '<div class="dropdown-item">No items available</div>';
        return;
      }

      items.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'dropdown-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = item;
        checkbox.checked = selectedItems.includes(item);
        
        const label = document.createElement('label');
        label.textContent = displayFormatter ? displayFormatter(item) : item;
        label.style.cursor = 'pointer';
        label.style.marginLeft = '0.25rem';
        
        itemDiv.appendChild(checkbox);
        itemDiv.appendChild(label);
        
        // Make the whole item clickable
        itemDiv.addEventListener('click', (e) => {
          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event('change'));
          }
        });
        
        content.appendChild(itemDiv);
      });
    }

    // Initialize dropdowns
    const bucketsDropdownControls = initializeDropdown(bucketsDropdown, () => {
      const checkboxes = bucketsDropdown.querySelectorAll('input[type="checkbox"]:checked');
      selectedBuckets = Array.from(checkboxes).map(cb => cb.value);
      updateDropdownText(bucketsDropdown, getAllBuckets(), selectedBuckets);
      updateCsvFields();
      loadMeasurements();
    });

    const measurementsDropdownControls = initializeDropdown(measurementsDropdown, () => {
      const checkboxes = measurementsDropdown.querySelectorAll('input[type="checkbox"]:checked');
      selectedMeasurements = Array.from(checkboxes).map(cb => cb.value);
      updateDropdownText(measurementsDropdown, getAllMeasurements(), selectedMeasurements, measurementDisplayFormatter);
      updateCsvFields();
      if (selectedMeasurements.length > 0) {
        loadAndRender();
      }
    });

    let allBuckets = [];
    let allMeasurements = [];

    function getAllBuckets() { return allBuckets; }
    function getAllMeasurements() { return allMeasurements; }

    // Load available buckets on page load
    async function loadBuckets() {
      try {
        const res = await fetch('/api/buckets');
        
        if (!res.ok) {
          console.error('Failed to load buckets: API returned error');
          allBuckets = [];
          updateDropdownText(bucketsDropdown, [], []);
          return;
        }
        
        const data = await res.json();
        allBuckets = data.buckets || [];
        
        if (allBuckets.length === 0) {
          updateDropdownText(bucketsDropdown, [], []);
          return;
        }
        
        populateDropdown(bucketsDropdown, allBuckets, selectedBuckets);
        updateDropdownText(bucketsDropdown, allBuckets, selectedBuckets);
        
        // Auto-select first bucket if available and none selected
        if (allBuckets.length > 0 && selectedBuckets.length === 0) {
          selectedBuckets = [allBuckets[0]];
          populateDropdown(bucketsDropdown, allBuckets, selectedBuckets);
          updateDropdownText(bucketsDropdown, allBuckets, selectedBuckets);
          await loadMeasurements();
        }
      } catch (err) {
        console.error('Failed to load buckets:', err);
        allBuckets = [];
        updateDropdownText(bucketsDropdown, [], []);
      }
    }

    // Load measurements for selected buckets
    async function loadMeasurements() {
      if (selectedBuckets.length === 0) {
        allMeasurements = [];
        populateDropdown(measurementsDropdown, [], []);
        updateDropdownText(measurementsDropdown, [], []);
        return;
      }
      
      try {
        const bucketsParam = selectedBuckets.join(',');
        const res = await fetch(`/api/measurements?buckets=${encodeURIComponent(bucketsParam)}`);
        
        if (!res.ok) {
          console.error('Failed to load measurements: API returned error');
          allMeasurements = [];
          selectedMeasurements = [];
          populateDropdown(measurementsDropdown, [], []);
          updateDropdownText(measurementsDropdown, [], []);
          return;
        }
        
        const data = await res.json();
        const measurements = data.measurements || [];

        allMeasurements = measurements;
        
        // Filter selectedMeasurements to only include measurements that still exist
        // This preserves user selection when possible, but removes invalid selections
        selectedMeasurements = selectedMeasurements.filter(m => allMeasurements.includes(m));

        if (allMeasurements.length === 0) {
          selectedMeasurements = [];
          populateDropdown(measurementsDropdown, [], []);
          updateDropdownText(measurementsDropdown, [], []);
          return;
        }

        // Use display formatter for bucket:measurement -> bucket (measurement)
        // (Using global formatter instead of local)

        // Auto-select first measurement only if no valid selections remain
        if (selectedMeasurements.length === 0 && allMeasurements.length > 0) {
          selectedMeasurements = [allMeasurements[0]];
        }

        populateDropdown(measurementsDropdown, allMeasurements, selectedMeasurements, measurementDisplayFormatter);
        updateDropdownText(measurementsDropdown, allMeasurements, selectedMeasurements, measurementDisplayFormatter);
        
        // Update CSV fields and render chart if measurements are selected
        updateCsvFields();
        if (selectedMeasurements.length > 0) {
          loadAndRender();
        }
      } catch (err) {
        console.error('Failed to load measurements:', err);
        allMeasurements = [];
        selectedMeasurements = [];
        populateDropdown(measurementsDropdown, [], []);
        updateDropdownText(measurementsDropdown, [], []);
      }
    }

    // Update CSV form fields with current selections
    function updateCsvFields() {
      const csvBuckets = document.getElementById('csvBuckets');
      const csvMeasurements = document.getElementById('csvMeasurements');
      if (csvBuckets) csvBuckets.value = selectedBuckets.join(',');
      if (csvMeasurements) csvMeasurements.value = selectedMeasurements.join(',');
    }

    // Toggle Modes
    btnRel.onclick = () => {
      btnRel.classList.add('active');
      btnAbs.classList.remove('active');
      relCtrls.style.display = 'flex';
      rangeInput.style.display = 'none';
      loadAndRender();
    };
    btnAbs.onclick = () => {
      btnRel.classList.remove('active');
      btnAbs.classList.add('active');
      relCtrls.style.display = 'none';
      rangeInput.style.display = 'inline-block';
    };

    // Quick-range Buttons
    relCtrls.querySelectorAll('[data-range]').forEach(btn => {
      btn.onclick = () => {
        currentRange = btn.dataset.range;
        relCtrls.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        csvRange.value = btn.dataset.range;
        csvStart.value = '';
        csvStop.value = '';
        loadAndRender();
      };
    });

    // Initialize Flatpickr for range selection (only if available)
    if (typeof flatpickr !== 'undefined') {
      flatpickr(rangeInput, {
        mode: 'range',
        enableTime: true,
        dateFormat: 'Y-m-d H:i',
        onClose: function(selectedDates) {
          if (selectedDates.length === 2) {
            const [start, stop] = selectedDates;
            csvStart.value = start.toISOString();
            csvStop.value  = stop.toISOString();
            csvRange.value = '';

            loadAndRender({
              start: start.toISOString(),
              stop:  stop.toISOString()
            });
          }
        }
      });
    } else {
      // Disable calendar mode if flatpickr is not available
      btnAbs.disabled = true;
      btnAbs.style.opacity = '0.5';
      btnAbs.style.cursor = 'not-allowed';
    }

    // Refresh button functionality
    refreshBtn.onclick = () => {
      if (selectedMeasurements.length > 0) {
        loadAndRender();
      }
    };


    // Fetch & Render Chart
    async function loadAndRender({ start, stop } = {}) {
      if (selectedMeasurements.length === 0) {
        return;
      }

      // Parse selectedMeasurements into buckets and measurements
      const bucketsSet = new Set();
      const measurementsList = [];
      selectedMeasurements.forEach(val => {
        if (val.includes(':')) {
          const [bucket, measurement] = val.split(':', 2);
          bucketsSet.add(bucket);
          measurementsList.push(measurement);
        } else {
          measurementsList.push(val);
        }
      });
      const bucketsArr = Array.from(bucketsSet);

      let url = `/api/sensors?limit=5000`;
      if (bucketsArr.length > 0) {
        url += `&buckets=${encodeURIComponent(bucketsArr.join(','))}`;
      } else if (selectedBuckets.length > 0) {
        url += `&buckets=${encodeURIComponent(selectedBuckets.join(','))}`;
      }
      url += `&measurements=${encodeURIComponent(measurementsList.join(','))}`;

      if (start && stop) {
        url += `&start=${encodeURIComponent(start)}&stop=${encodeURIComponent(stop)}`;
        csvStart.value = start.toISOString();
        csvStop.value  = stop.toISOString();
        csvRange.value = '';
      } else {
        url += `&range=${currentRange}`;
        csvRange.value = currentRange;
        csvStart.value = '';
        csvStop.value = '';
      }

      updateCsvFields();

      try {
        const res = await fetch(url);
        const { readings } = await res.json();

        // Group readings by bucket:measurement for charting
        const datasetsByMeasurement = {};
        readings.forEach(reading => {
          // Use bucket:measurement as key for uniqueness
          const key = (reading.bucket && reading.measurement) ? `${reading.bucket}:${reading.measurement}` : (reading.measurement || 'Unknown');
          if (!datasetsByMeasurement[key]) {
            datasetsByMeasurement[key] = {
              timestamps: [],
              values: []
            };
          }
          datasetsByMeasurement[key].timestamps.push(reading.timestamp);
          datasetsByMeasurement[key].values.push(reading.value);
        });

        // Create datasets for chart, show label as bucket (measurement)
        const datasets = Object.keys(datasetsByMeasurement).map((measurement, index) => {
          const colors = [
            '#1e88e5', '#e53935', '#43a047', '#fb8c00',
            '#8e24aa', '#00acc1', '#fdd835', '#f4511e'
          ];
          const color = colors[index % colors.length];
          // Convert hex to rgba for background
          const hex = color.slice(1);
          const r = parseInt(hex.slice(0, 2), 16);
          const g = parseInt(hex.slice(2, 4), 16);
          const b = parseInt(hex.slice(4, 6), 16);
          const backgroundColor = `rgba(${r}, ${g}, ${b}, 0.2)`;
          let label = measurement;
          if (measurement.includes(':')) {
            const [bucket, m] = measurement.split(':', 2);
            label = `${bucket} (${m})`;
          }
          return {
            label: label,
            data: datasetsByMeasurement[measurement].values,
            borderColor: color,
            backgroundColor: backgroundColor,
            fill: false,
            tension: 0.3
          };
        });

        // Use timestamps from first dataset for labels (assuming all have similar timestamps)
        const labels = Object.keys(datasetsByMeasurement).length > 0
          ? Object.values(datasetsByMeasurement)[0].timestamps.map(t => new Date(t).toLocaleString())
          : [];

        // Chart rendering (only if Chart.js is available)
        if (typeof Chart !== 'undefined') {
          if (chart) {
            chart.data.labels = labels;
            chart.data.datasets = datasets;
            chart.update();
          } else {
            const ctx = document.getElementById('sensorChart').getContext('2d');
            chart = new Chart(ctx, {
              type: 'line',
              data: {
                labels,
                datasets
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: {
                    title: { display: true, text: 'Time' }
                  },
                  y: {
                    title: { display: true, text: 'Value' }
                  }
                },
                plugins: {
                  legend: {
                    display: true,
                    position: 'top'
                  }
                }
              }
            });
          }
        } else {
          // Display message when Chart.js is not available
          const chartContainer = document.getElementById('chart-container');
          chartContainer.innerHTML = '<p style="text-align: center; color: #666;">Chart display requires Chart.js library to be loaded.</p>';
        }

        // --- Statistics Table ---
        const statsTable = document.getElementById('stats-table').querySelector('tbody');
        statsTable.innerHTML = '';
        Object.keys(datasetsByMeasurement).forEach(measurement => {
          const values = datasetsByMeasurement[measurement].values;
          if (!values.length) return;
          const min = Math.min(...values);
          const max = Math.max(...values);
          const avg = values.reduce((a, b) => a + b, 0) / values.length;
          let label = measurement;
          if (measurement.includes(':')) {
            const [bucket, m] = measurement.split(':', 2);
            label = `${bucket} (${m})`;
          }
          const row = document.createElement('tr');
          row.innerHTML = `
            <td style="padding:0.5rem;">${label}</td>
            <td style="padding:0.5rem; text-align:right;">${min.toFixed(2)}</td>
            <td style="padding:0.5rem; text-align:right;">${avg.toFixed(2)}</td>
            <td style="padding:0.5rem; text-align:right;">${max.toFixed(2)}</td>
          `;
          statsTable.appendChild(row);
        });
        // --- End Statistics Table ---

      } catch (err) {
        console.error('Failed to load sensor data:', err);
      }
    }

    // Initial load
    loadBuckets();
  </script>
</body>
</html>
